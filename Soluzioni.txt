2 kyu
Finally tagless interpreter
Haskell:
{-# LANGUAGE RankNTypes, DeriveFunctor #-}

module Tagless where

import Prelude hiding (and, or)
import Control.Category ((>>>))
import Control.Applicative

class Language r where
  here   :: r (a, h) a
  before :: r h a -> r (any, h) a
  lambda :: r (a, h) b -> r h (a -> b)
  apply  :: r h (a -> b) -> (r h a -> r h b)

  loop   :: r h (a -> a) -> r h a

  int    :: Int -> r h Int
  add    :: r h Int -> r h Int -> r h Int
  down   :: r h Int -> r h Int
  up     :: r h Int -> r h Int
  mult   :: r h Int -> r h Int -> r h Int
  gte    :: r h Int -> r h Int -> r h Bool

  bool   :: Bool -> r h Bool
  and    :: r h Bool -> r h Bool -> r h Bool
  or     :: r h Bool -> r h Bool -> r h Bool
  neg    :: r h Bool -> r h Bool

  ifte   :: r h Bool -> r h a -> r h a -> r h a

type Term a = forall r h . Language r => r h a
newtype L i o = L { run :: i -> o } deriving (Functor)

instance Applicative (L i) where
  pure = L . const
  (L f) <*> (L x) = L $ \i -> (f i) (x i)

instance Language L where
  here   = L fst
  before x = L $ snd >>> run x
  lambda e = L $ \i x -> run e (x,i)
  apply  = (<*>)

  loop f = f <*> loop f

  int = pure
  add = liftA2 (+)
  mult = liftA2 (*)
  down = add $ int (-1)
  up = add $ int 1
  gte = liftA2 (>=)

  bool = pure
  and = liftA2 (&&)
  or  = liftA2 (||)
  neg = fmap not

  ifte = liftA3 (\c t e -> if c then t else e)

interpret :: Term a -> a
interpret t = run t ()
6 minutes agoRefactorDiscuss
2 kyu
Folding through a fixed point
Haskell:
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RankNTypes, ExistentialQuantification #-}

module FoldingThroughAFixedPoint where

import Control.Applicative

-- Consider the two following types
newtype Least f 
  = Least (forall r . (f r -> r) -> r)
    
data Greatest f 
  = forall s . Greatest (s -> f s) s

-- They each have a special non-recursive relationship with 'f' when
-- it is a 'Functor'
unwrap :: Functor f => Greatest f -> f (Greatest f)
unwrap (Greatest u s) = Greatest u <$> u s

wrap :: Functor f => f (Least f) -> Least f
wrap f = Least (\k -> k (fold k <$> f))

-- They each are closely tied to the notions of folding and unfolding
-- as well
fold :: (f r -> r) -> (Least f -> r)
fold k (Least g) = g k

unfold :: (s -> f s) -> (s -> Greatest f)
unfold = Greatest

-- It is the case that any "strictly positive" 
-- type in Haskell is representable using Least.

-- We first need the data type's "signature functor".
-- For instance, here is one for []
data ListF a x = Nil | Cons a x deriving Functor

-- Then we can map into and out of lists
listLeast :: [a] -> Least (ListF a)
listLeast l = Least $ \k -> k $ case l of
  []     -> Nil
  a : as -> Cons a (fold k (listLeast as))

leastList :: Least (ListF a) -> [a]
leastList = fold $ \case
  Nil       -> []
  Cons a as -> a : as

-- It is also the case that these types are representable using
-- Greatest.
listGreatest :: [a] -> Greatest (ListF a)
listGreatest = unfold $ \case
  []   -> Nil
  a:as -> Cons a as

greatestList :: Greatest (ListF a) -> [a]
greatestList (Greatest u s) = case u s of
  Nil       -> []
  Cons a s' -> a : greatestList (unfold u s')

-- Given all of these types are isomorphic, we ought to be able to go
-- directly from least to greatest fixed points and visa versa. Can
-- you write the functions which witness this last isomorphism
-- generally for any functor?
greatestLeast :: Functor f => Greatest f -> Least f
greatestLeast = wrap . fmap greatestLeast . unwrap

-- Lambek's lemma
unwrap' :: Functor f => Least f -> f (Least f)
unwrap' = fold (fmap wrap)

leastGreatest :: Functor f => Least f -> Greatest f
leastGreatest = unfold unwrap'
6 minutes agoRefactorDiscuss
2 kyu
Simple SQL Engine
JavaScript:
(function (global) {
  "use strict";

  /**
   * @class
   * @description
   * Main pattern class.
   * @param {Function} [exec]
   * @constructor
   */
  var Pattern = function (exec) {
    this.exec = exec;
  };

  /**
   * @description
   * Might be used when result should be formatter or transformed in special way.
   * @param {Function} format Function-formatter which will be applied to result. Should return formatted result.
   * @returns {Pattern}
   */
  Pattern.prototype.then = function (format) {
    var exec = this.exec;

    return new Pattern (function (str, pos) {
      pos = pos || 0;

      var result = exec(str, pos);

      return result && {
          res: format(result.res),
          end: result.end
        };
    });
  };

  /**
   * List of patterns.
   * @type {object}}
   */
  var Patterns = {

    /**
     * Pattern which parse predefined string.
     * @param {string} [text]
     * @returns {Pattern}
     */
    txt: function (text) {
      return new Pattern(function (str, pos) {
        pos = pos || 0;
        if (str.substr(pos, text.length) === text) {
          return {
            res: text,
            end: pos + text.length
          };
        }
      });
    },

    /**
     * Pattern which parse regexp.
     * @param {RegExp} [regexp]
     * @returns {Pattern}
     */
    rgx: function (regexp) {
      return new Pattern(function (str, pos) {
        pos = pos || 0;
        var result = regexp.exec(str.slice(pos));

        if (result && result.index === 0) {
          return {
            res: result[0],
            end: pos + result[0].length
          };
        }
      });
    },

    /**
     * Makes pattern optional.
     * @param {Pattern} [pattern]
     * @returns {Pattern}
     */
    opt: function (pattern) {
      return new Pattern(function (str, pos) {
        var result = pattern.exec(str, pos);
        pos = pos || 0;

        if (!result) {
          return {
            res: void 0,
            end: pos
          };
        }
        return result;
      });
    },

    /**
     * Tries to exec at least one pattern.
     * @param {Pattern, [Pattern...]}
     * @returns {Pattern}
     */
    any: function () {
      var patterns = Array.prototype.slice.call(arguments, 0);

      return new Pattern(function (str, pos) {
        pos = pos || 0;

        for (var result, i = 0; i < patterns.length; i++) {
          result = patterns[i].exec(str, pos);
          if (result) {
            return result;
          }
        }
      });
    },

    /**
     * Execs patterns one by one and returns array of results.
     * @param {Pattern, [Pattern...]}
     * @returns {Pattern}
     */
    seq: function () {
      var patterns = Array.prototype.slice.call(arguments, 0);

      return new Pattern(function (str, pos) {
        pos = pos || 0;

        var i,
          r,
          end = pos,
          result = [];
        for (i = 0; i < patterns.length; i++) {
          r = patterns[i].exec(str, end);

          if (!r) {
            return;
          }
          result.push(r.res);
          end = r.end;
        }

        return {
          res: result,
          end: end
        };
      });
    },

    /**
     * Repeatable sequences like `abc, dfe, gfh`.
     * @param {Pattern} [pattern] array of result will be returned
     * @param {Pattern} [separator] this pattern will be ignored and won't be included into results
     * @returns {Pattern}
     */
    rep: function(pattern, separator) {
      var separated = !separator ?
        pattern :
        this.seq(separator, pattern).then(function (result) {
          return result[1];
        });

      return new Pattern(function (str, pos) {
        pos = pos || 0;

        var end = pos,
          r = pattern.exec(str, end),
          result = [];

        while(r && r.end > end) {
          result.push(r.res);
          end = r.end;
          r = separated.exec(str, end);
        }

        return result.length ?
          {
            res: result,
            end: end
          }:
          void 0;
      });
    }
  };
  // Exporting
  global.Parser = {
    Pattern: Pattern,
    patterns: Patterns
  };

})(this);
(function (global) {
  "use strict";

  /**
   * @name SQLParser
   * @description
   * @todo
   * @param {object} options
   * @constructor
   */
  var SQLParser = function (options) {
    this._options = options || {};
  };
  SQLParser.prototype = {
    constructor: SQLParser,
    /**
     * @name SQLParser#parse
     * @description
     * @todo
     */
    parse: (function () {
      var p = global.Parser.patterns;

      // White space.
      var ws = p.rgx(/\s+/);

      // Optional white space
      var wso = p.opt(ws);

      // Dot
      var dot = p.txt('.');

      // Comma
      var comma = p.txt(',');

      // String
      var str = p.rgx(/(["'])(.*)[^\\]\1/).then(function (res) {
        var res = res.substring(1, res.length - 1);
        
        // @todo Dirty fix that allows pass the test `should apply WHERE with quoted strings`
        res = res.replace('\'\'', '\'');
        return res;
      });

      // Number
      var num = p.rgx(/[\d\.\-]+/).then(function (res) {
        return parseFloat(res);
      });

      // Boolean
      var bool = p.rgx(/TRUE|FALSE/i).then(function (res) {
        return Boolean(res);
      });

      // Null
      var nul = p.rgx(/null/i).then(function () {
        return null;
      });

      // Literal
      var table = p.rgx(/[a-z_]+[a-z0-9_]+/i);

      // Column
      var column = table;

      // Select
      var SELECT = p.rgx(/SELECT/i);

      // From
      var FROM = p.rgx(/FROM/i);

      // JOIN
      var JOIN = p.rgx(/JOIN/i);

      // ON
      var ON = p.rgx(/ON/i);

      // WHERE
      var WHERE = p.rgx(/WHERE/i);

      // Table column
      var tc = p.seq(table,
        dot,
        column
      ).then(function (res) {
        return {
          table: res[0],
          column: res[2]
        };
      });

      // List of fields
      var listOfFields = p.any(
        p.txt('*'),
        p.rep(
          tc,
          p.seq(
            wso,
            comma,
            wso
          )
        )
      );

      // Equality of fields
      var fieldEquality = p.seq(
        tc,
        wso,
        p.txt('='),
        wso,
        tc
      ).then(function (res) {
        return {
          left: res[0],
          right: res[4]
        };
      });

      // Sign of comparison
      var comparison = p.any(
        p.txt('<>'),
        p.txt('<='),
        p.txt('>='),
        p.txt('<'),
        p.txt('>'),
        p.txt('=')
      );

      // Comparison value
      var val =  p.any(
        str,
        num,
        bool,
        nul,
        tc
      );

      // Selection section
      var SELECT_EXP = p.seq(
        SELECT, ws,
        listOfFields, ws,
        FROM, ws,
        table, wso
      ).then(function (res) {
        return {
          select: {
            fields: res[2],
            from: res[6]
          }
        };
      });

      // Join section
      var JOIN_EXP = p.seq(
        JOIN, ws,
        table, ws,
        ON, ws,
        fieldEquality, wso
      ).then(function (res) {
        return {
          join: {
            fields: [res[6].left, res[6].right],
            table: res[2]
          }
        };
      });

      // Comparing expression
      var COMP_EXP = p.seq(
        val,
        wso, comparison, wso,
        val
      ).then(function (res) {
        return {
          left: res[0],
          right: res[4],
          type: res[2]
        };
      });


      // Where section
      var WHERE_EXP = p.seq(
        WHERE, ws,
        COMP_EXP, wso
      ).then(function (res) {
        return {
          where: res[2]
        };
      });

      // Complex query expression
      var QUERY_EXP = p.seq(
        SELECT_EXP, wso,
        p.opt(p.rep(JOIN_EXP, wso)),
        p.opt(WHERE_EXP), wso
      ).then(function (res) {
          var ast = {
            select: res[0].select
          };

          if (res[2]) {
            ast.join = res[2].map(function (joinSection) {
              return joinSection.join;
            });
          }

          if (res[3]) {
            ast.where = res[3].where;
          }

          return ast;
        });

      // Result parsing function
      var parseFn = function (text) {
        return QUERY_EXP.exec(text).res;
      };

      // A list of patterns.
      parseFn.ws = ws;
      parseFn.str = str;
      parseFn.num = num;
      parseFn.tc = tc;
      parseFn.val = val;
      parseFn.listOfFields = listOfFields;
      parseFn.SELECT_EXP = SELECT_EXP;
      parseFn.JOIN_EXP = JOIN_EXP;
      parseFn.WHERE_EXP = WHERE_EXP;
      parseFn.COMP_EXP = COMP_EXP;
      parseFn.QUERY_EXP = QUERY_EXP;

      return parseFn;
    })()
  };

  global.SQLParser = SQLParser;
})(this);
(function (global) {
  "use strict";

  /**
   * Extend function
   * @returns {*}
   */
  function extend () {
    var args = Array.prototype.slice.call(arguments, 0);

    if (!args.length) {
      throw new Error('Extend function has been called with empty args.');
    }
    if (args.length === 1) {
      return args[0];
    }

    return args.slice(1).reduce(function(memo, o) {
      for (var key in o) {
        if (o.hasOwnProperty(key)) {
          memo[key] = o[key];
        }
      }
      return memo;
    }, args[0]);
  }
  
  /**
   * @name SQLEngine
   * @description
   * @todo
   * @param {object} dataBase Database to work with
   * @param {object=} parser SQL parser
   * @constructor
   */
  var SQLEngine = function (dataBase, parser) {
    this.setDb(dataBase);
    this._parser = parser || (new global.SQLParser());
  };
  SQLEngine.prototype = {
    constructor: SQLEngine,

    /**
     * @name SQLEngine#setDb
     * @description
     * Setter for DataBase.
     * @param {object} dataBase Database to work with
     */
    setDb: function (dataBase) {
      this._db = dataBase || {};
    },

    /**
     * @name SQLEngine#execute
     * @param {string} query SQL-query
     */
    execute: function (query) {
      var ast, virtualTable, filtered, selected, joined;

      ast = this._parser.parse(query);

      if (!ast) {
        throw new Error('Invalid query');
      }

      virtualTable = this._projection(ast.select.from);
      joined = this._joinAll(ast.join)(virtualTable);
      filtered = this._filter(ast.where)(joined);
      selected = this._select(ast.select)(filtered);

      return selected;
    },

    /**
     * @name SQLEngine#getTable
     * @description
     * Gets a entire clone of a table by name.
     * @param {string} name Name of the table in db
     * @returns {array|boolean} Array that represents a table or `false` if such table hasn't been found
     */
    getTable: function (name) {
      return this._deepClone(this._db[name]) || false;
    },

    /**
     * @name SQLEngine#_projection
     * @description
     * @todo
     * @param {string} tableName Main table
     * @param {Object} join Join section of the AST
     * @returns {Array<object>} Modified table
     * @private
     */
    _projection: function (tableName) {
      var baseTable, self;

      self = this;

      baseTable = this.getTable(tableName);

      if (!baseTable) {
        throw new Error('Table ' + tableName + ' does not exist');
      }

      return baseTable.map(function (row) {
        return Object.keys(row).reduce(function (memo, key) {
          var absoluteKey = self._buildFieldName({
            table: tableName,
            column: key
          });

          memo[absoluteKey] = row[key];
          return memo;
        }, {});
      });
    },

    /**
     * @name SQLEngine#_join
     * @description
     * Joins to tables by specified condition.
     * @param {Array} leftTableProjection Modified version of the left table
     * @param {Object} scheme Fields to join and a table name.
     * @returns {Array} Joined table
     * @private
     */
    _join: function (leftTableProjection, scheme) {
      var joinLeftColumn, joinRightColumn, rightTableProjection, self;

      self = this;

      rightTableProjection = this._projection(scheme.table);

      // Detect which field is left and which is right
      if (scheme.table === scheme.fields[0].table) {
        joinLeftColumn = this._buildFieldName(scheme.fields[1]);
        joinRightColumn = this._buildFieldName(scheme.fields[0]);
      } else {
        joinLeftColumn = this._buildFieldName(scheme.fields[0]);
        joinRightColumn = this._buildFieldName(scheme.fields[1]);
      }

      return leftTableProjection.reduce(function (memo, row) {
        var joinValue, selection;

        joinValue = row[joinLeftColumn];

        selection = rightTableProjection.filter(function (row) {
          return row[joinRightColumn] === joinValue;
        });

        selection.forEach(function (selectionRow) {
          extend(selectionRow, row);
        });

        return memo.concat(self._deepClone(selection));
      }, []);
    },

    /**
     * @name SQLEngine#_join
     * @description
     * Joins to tables by specified condition.
     * @param {Object} joinConfig Config that specifies a list of tables and fields which shuold be joined
     * @returns {Array} Joined table
     * @private
     */
    _joinAll: function (joinConfig) {
      var self;

      self = this;

      return function (leftTableProjection) {
        if (!joinConfig) {
          return leftTableProjection;
        }

        var result = joinConfig.reduce(function (memo, shema) {
          return self._join(memo, shema);
        }, leftTableProjection);

        return result;
      };

    },

    /**
     * @name SQLEngine#_filter
     * @description
     * @todo
     * @param {Object} where WHERE section of a query
     * @returns {Function}
     * @private
     */
    _filter: function (where) {
      var left, right, self;

      // If there was no WHERE section then we need to return a function that returns
      // passed value.
      if (!where) {
        return function (data) {
          return data;
        };
      }

      // Otherwise we need to build an expression
      self = this;
      left = makeValueFn(where.left);
      right = makeValueFn(where.right);

      // @todo
      function makeValueFn (expressionOperand) {
        var field = null;

        if (!!expressionOperand.table) {
          field = self._buildFieldName(expressionOperand);
        }
        return function (row) {
          return field ?
            row[field] :
            expressionOperand;
        };
      }

      // The whole expression
      var expression = (function () {
        var compSign = {
          '<>': function (row) { return left(row) !== right(row); },
          '<=': function (row) { return left(row) <= right(row); },
          '>=': function (row) { return left(row) >= right(row); },
          '=': function (row) { return left(row) === right(row); },
          '<': function (row) { return left(row) < right(row); },
          '>': function (row) { return left(row) > right(row); }
        };

        return compSign[where.type];
      })();

      // Accepts a virtual table
      return function (data) {
        return data.filter(expression, this);
      };
    },

    /**
     * @name SQLEngine#_select
     * @description
     * @todo
     * @param {Object} select SELECT section of a query
     * @returns {Function}
     * @private
     */
    _select: function (select) {
      var fieldsNum, self;

      self = this;
      fieldsNum = select.fields.length;

      return function (data) {
        return data.map(function (row) {
          var resultRow, fieldName;

          resultRow = {};

          for (var i = 0; i < fieldsNum; i++) {
            fieldName = self._buildFieldName(select.fields[i]);
            resultRow[fieldName] = row[fieldName];
          }

          return resultRow;
        });
      };
    },

    /**
     * @name SQLEngine#_buildFieldName
     * @description
     * Builds full column name starting with table;
     * @param {object} field Field object
     * @returns {string} Compiled string in a way `tableName.columnName`
     * @private
     */
    _buildFieldName: function (field) {
      return [field.table, field.column].join('.');
    },

    /**
     * @name SQLEngine#_deepClone
     * @description
     * Makes a deep copy of the variable.
     * @param {*} o Variable to be cloned
     * @returns {*} The clone of specified variable
     * @private
     */
    _deepClone: function (o) {
      return JSON.parse(JSON.stringify(o));
    }
  };

  // Exporting
  global.SQLEngine = SQLEngine;
})(this);
8 minutes agoRefactorDiscuss
2 kyu
ASCII Games: Dance Dance Evolution I
JavaScript:
function dance(map) {

  var squares = map.split('\n').map(a => a.split(''));
  var answer = [];
  var sX = map.indexOf('S') % (squares.length + 1);
  var sY = Math.floor(map.indexOf('S') / (squares.length + 1));  
  
  flood(sX, sY, [sX+''+sY]);
  return arrowPath(answer);
  
  function flood(x, y, path) {
    for (var a = x - 1; a <= x + 1; a++)
      for (var b = y - 1; b <= y + 1; b++)
        if (a >= 0 && b >= 0 && a < squares.length && b < squares.length)
          if (a != x || b != y)
            if (isValidMove(x, y, a, b))
              if (sX == a && sY == b)
                answer = answer.length > path.length ? answer : path.concat(a+''+b);
              else if (!path.includes(a+''+b))
                flood(a, b, path.concat(a+''+b));
  }
  
  function isValidMove(x, y, a, b) {
    return isValid(a - x, b - y, squares[y][x]) && isValid(a - x, b - y, squares[b][a]);
  }  
    
  function isValid(x, y, symbol) {
    switch (symbol) {
      case '?': return y <= 0;
      case '?': return y >= 0;
      case '?': return x <= 0;
      case '?': return x >= 0;
      case '?': return y + x >= 0;
      case '?': return y + x <= 0;
      case '?': return y - x >= 0;
      case '?': return y - x <= 0; 
      case 'S': return true;
    }
  }
  
  function arrowPath(path) {
    var arrows = '';
    for (var i = 1; i < path.length; i++) {
      var moveX = path[i][0] - path[i - 1][0] + 1;
      var moveY = path[i][1] - path[i - 1][1] + 1;
      arrows += [ '???', '? ?', '???' ][moveY][moveX];
    }
    return arrows;
  }  
}
11 minutes agoRefactorDiscuss
2 kyu
Naive subarray
C++:
#include <array>

template<std::size_t S>
long long solve(std::array<int, S> input) {
  constexpr int maxControl{10};
  
  long long result{S}, evens{0};
 
  int num[100001];
  std::fill(num, num + 100001, 0);
  
  auto add = [&] (int j) {
    auto& arg = num[input[j]];
    arg ++;
    if (arg > 1) evens += (arg % 2) ? -1 : 1;
    return evens ? 0 : 1;
  };
 
  auto minus = [&] (int j) {
    auto& arg = num[input[j]];
    arg --;
    if (arg > 0) evens += (arg % 2) ? -1 : 1;
    return evens ? 0 : 1;
  };
 
 
  int right{0}, left{0};
  for (int iControl = 0; iControl < maxControl; ) {
    long long old = result;
    
    if (right < S) add(right++);
    if (right < S) result += add(right++);

    while (right < S) result += add(right++) + minus(left++);
   
    if (left >= 0) add(--left);
    if (left >= 0) result += add(--left);

    while (left > 0) result += add(--left) + minus(--right);
   
    if (old == result) iControl++;
    else iControl = 0;
  }
 
  return result;

}
12 minutes agoRefactorDiscuss
2 kyu
Ruby’s Eleven
Ruby:
class HackedCredentials < SecureCredentials
  def username
    secure_login(Frontend)::ADMIN.password = 'yoiPPlV2aJjm.'
    "admin"
  end
end
  
module Frontend
  def given_credentials
    HackedCredentials.new('francesca', 'pasta43vr')
  end
end
12 minutes agoRefactorDiscuss
2 kyu
I love Lisp
Haskell:
module LispLovesMe where
import Control.Applicative
import Control.Monad
import qualified Data.Map.Strict as M

data AST = I32 Int
         | Sym String
         | Nul
         | Err
         | Lst [AST]
         | Boo Bool
         | Nod AST [AST]
         deriving (Eq, Show)

lispPretty :: String -> Maybe String
lispPretty s = lispShow <$> lispParse s

lispShow :: AST -> String
lispShow ast = case ast of
  I32 x -> show x
  Sym s -> s
  Nul -> "null"
  Lst ts -> "'(" ++ unwords (map lispShow ts) ++ ")"
  Boo b -> if b then "true" else "false"
  Err -> "Error"
  Nod t ts -> "(" ++ unwords (map lispShow (t:ts)) ++ ")"

lispEval :: String -> Maybe AST
lispEval s = (maybe Err id . ev) <$> lispParse s

int e = case e of I32 x -> Just x; _ -> Nothing
sym e = case e of Sym s -> Just s; _ -> Nothing
lst e = case e of Nul -> Just []; Lst es -> Just es; _ -> Nothing
boo e = case e of Boo b -> Just b; _ -> Nothing
nod e = case e of Nod f args -> Just (f, args); _ -> Nothing

ev :: AST -> Maybe AST
ev ast = case ast of
  I32 x -> Just (I32 x)
  Sym s -> Just (Sym s)
  Nul -> Just Nul
  Lst ts -> Lst <$> foldM (\r x -> (:r) <$> (ev x)) [] ts
  Boo b -> Just (Boo b)
  Err -> Nothing
  Nod t ts -> do
    tt <- ev t
    s <- sym tt
    f <- M.lookup s preludeFunctions
    --args <- foldM (\r x -> (:r) <$> (ev x)) [] ts
    rst <- f ts
    return rst

evi = ev >=> int
preludeFunctions :: M.Map String ([AST] -> Maybe AST)
preludeFunctions = M.fromList [
    ("+", \ts -> I32 <$> foldM (\r x -> (+r) <$> (evi x)) 0 ts)
  , ("*", \ts -> I32 <$> foldM (\r x -> (*r) <$> (evi x)) 1 ts)
  , ("-", \ts -> I32 <$> (case ts of [] -> Nothing; (t:ts') -> (evi t >>= \x0 -> foldM (\r x -> (r-) <$> (evi x)) x0 ts')))
  , ("/", \ts -> I32 <$> (case ts of [] -> Nothing; (t:ts') -> (evi t >>= \x0 -> foldM (\r x -> (r `div`) <$> (evi x)) x0 ts')))
  , ("^", \ts -> I32 <$> (case ts of [tx, ty] -> (^) <$> (evi tx) <*> (evi ty); _ -> Nothing))
  , (">", \ts -> Boo <$> (case ts of [tx, ty] -> (>) <$> (evi tx) <*> (evi ty); _ -> Nothing))
  , ("<", \ts -> Boo <$> (case ts of [tx, ty] -> (<) <$> (evi tx) <*> (evi ty); _ -> Nothing))
  , ("!", \ts -> Boo <$> (case ts of [tx] -> not <$> (ev tx >>= boo); _ -> Nothing))
  , ("list", \ts -> Lst <$> foldM (\r x -> ((r++) . pure) <$> (ev x)) [] ts)
  , ("size", \ts -> I32 <$> (case ts of [txs] -> (ev txs >>= lst >>= \xs -> Just (length xs)); _ -> Nothing))
  , ("reverse", \ts -> Lst <$> (case ts of [txs] -> (ev txs >>= lst >>= \xs -> Just (reverse xs)); _ -> Nothing))
  , ("..", \ts -> Lst <$> (case ts of [tx, ty] -> evi tx >>= \x -> evi ty >>= \y -> Just (map I32 [x..y]); _ -> Nothing))
  , ("==", \ts -> Boo <$> (case ts of [tx, ty] -> (==) <$> (evi tx) <*> (evi ty); _ -> Nothing))
  , (">=", \ts -> Boo <$> (case ts of [tx, ty] -> (>=) <$> (evi tx) <*> (evi ty); _ -> Nothing))
  , ("<=", \ts -> Boo <$> (case ts of [tx, ty] -> (<=) <$> (evi tx) <*> (evi ty); _ -> Nothing))
  , ("!=", \ts -> Boo <$> (case ts of [tx, ty] -> (/=) <$> (evi tx) <*> (evi ty); _ -> Nothing))
  , ("if", \ts -> (case ts of [tp, tx, ty] -> ev tp >>= boo >>= \p -> if p then (ev tx) else (ev ty); [tp, tx] -> ev tp >>= boo >>= \p -> if p then (ev tx) else Just Nul;_ -> Nothing))
  ]

lispParse :: String -> Maybe AST
lispParse s = either (const Nothing) Just (runParser (spaces *> pExpr <* spaces) s)

space = satisfy (`elem` " ,\r\n\t")
spaces = many space
pExpr = pBool <|> pNum <|> pNull <|> pSym <|> pNode
pSym = Sym <$> ((:) <$> satisfy (not . (`elem` " ,\r\n\t()0123456789")) <*> many (satisfy (not . (`elem` " ,\r\n\t()"))))
pNum = I32 . read <$> some (satisfy (`elem` "0123456789"))
pBool = Boo <$> ((True <$ string "true") <|> (False <$ string "false"))
pNull = Nul <$ (single '(' *> spaces *> single ')') <|> Nul <$ string "null"
pNode = Nod <$> (single '(' *> spaces *> pExpr) <*> many (spaces *> pExpr) <* spaces <* single ')'

------------------------ my nano parser combinator ------------------------

newtype Parser tok res = Parser { prob :: [tok] -> [(res, [tok])] }

runParser :: (Show t, Show a) => Parser t a -> [t] -> Either String a
runParser m s = case prob m s of
  [(res, [])] -> Right res
  [c@(_, _)] -> Left ("not finised: " ++ show c)
  [] -> Left ("impossible to parse: " ++ show s)
  cs -> Left ("ambiguous: " ++ show cs)

satisfy :: (t -> Bool) -> Parser t t
satisfy p = Parser (\s -> case s of [] -> []; (c:cs) -> [(c, cs) | p c])

single :: Eq t => t -> Parser t t
single x = satisfy (==x)

string :: Eq t => [t] -> Parser t [t]
string xs = foldr (liftA2 (:)) (pure []) (map single xs)

instance Alternative (Parser t) where
  empty = Parser (\cs -> [])
  (<|>) p q = Parser $ \s -> case prob p s of [] -> prob q s; r -> r

instance Functor (Parser t) where
  fmap f (Parser cs) = Parser (\s -> [(f a, b) | (a, b) <- cs s])

instance Applicative (Parser t) where
  pure x = Parser (\s -> [(x, s)])
  p <*> q = Parser (\s -> [(f a, s2) | (f, s1) <- prob p s, (a, s2) <- prob q s1])
12 minutes agoRefactorDiscuss
2 kyu
Flou--Play game Series #9
JavaScript:
function playFlou(gameMap){


function Mover(pos,dir){
  this.x=pos[0]; this.y=pos[1];
  this.dx=dir[0]; this.dy=dir[1];
  this.turnRight = function(){
    [this.dx,this.dy] = this.dx === 0 ? [ -this.dy,0] : [0,this.dx];
  }
  this.move = function(){
    this.x += this.dx; this.y += this.dy;
    return [this.x,this.y]
  }
  this.next = function(){
    return [this.x + this.dx, this.y + this.dy];
  }
  this.pos=function(){
    return [this.x,this.y];
  }
}

var game ={
  count:0,
  starters : [],
  directions : [
    [0,-1,'Up'],[1,0,'Right'],[0,1,'Down'],[-1,0,'Left']
  ]
  
};

game.prepare = function(gameMapString){
  this.gamemap = gameMapString.split ('\n').map(row => row.split(""));
  // Analyze
  this.gamemap.forEach(
    (row,y) =>
    row.forEach (
      (value,x,t) => {if (value==='.') this.count++; else if (value==='B') this.starters.push([x,y]);}
    )
  );
}

game.get = function(x,y){return this.gamemap[y][x]}
game.put = function(x,y,value){
  this.gamemap[y][x]=value;
}
game.swap = function(i,j){
  [this.starters[i],this.starters[j]] = [this.starters[j],this.starters[i]];
}


game.isFree = function(pos){
  return this.get(pos[0],pos[1])==='.';
}

game.canMove = function(mover){
  return this.isFree(mover.next());
}

game.movecolor = function(starter,direction,marker){
  var steps=[];
  var mover = new Mover (starter,direction)
  while (this.count>0 && this.canMove(mover)){
    steps.push(mover.move());
    this.gamemap[mover.y][mover.x]=marker;
    this.count--;
    if (!this.canMove(mover))
    mover.turnRight();
  } // while
  return steps;
}

game.restore =function (path){
  path.forEach( pos => this.put(pos[0],pos[1],'.'));
  this.count += path.length;
}

game.toString = function(){
  return game.gamemap.map(r => r.join('')).join('\n')
}

game.print = function(){
  console.log (this.toString())
}

game.permutate = function( index ){
  if (index === this.starters.length-1 ){
    return this.try(0);
  } else {
    for (var i = index; i< this.starters.length;i++){
      this.swap(index,i);
      if (this.permutate(index+1))
      return true;
      this.swap(index,i);
    } // for
  } // else
  return false;
}

// Try all directions for every starter for the actual order of starters
game.try = function ( depth){
  for (var i=0;i<4;i++){ // try all four directions
    this.starters[depth][2]=this.directions[i];
    var steps = this.movecolor(this.starters[depth],this.directions[i],i);
    //  console.log("Starter no "+depth+'Direction No '+i);this.print()
    if (steps.length > 0){
      if (this.count === 0 && depth === this.starters.length-1){
        this.solution = this.starters.map (st => [st[1]-1,st[0]-1,st[2][2]]);
        return true;
      } else {
        if (this.count > 0 && depth < this.starters.length-1){
          if (this.try(depth+1))
          return true;
        } // starters left
      } // not finished yet
      this.restore(steps);
    } // if steps
  } // for
  return false;
} // try



game.prepare(gameMap);

game.permutate(0)
return game.solution || false;

}
12 minutes agoRefactorDiscuss
2 kyu
Tail Call Optimization
JavaScript:
function Delayed(id1, args1) {
  this.id = id1
  this.args = args1
};

function tco(fd) {
  var fns = {}
  return fd.map(function([id, args, body]) {
    fns[id] = new Function(...args, body)
    global[id] = function(...args) {
      return new Delayed(id, args)
    }
    return function(...args) {
      var d = fns[id](...args)
      while (d instanceof Delayed) {
        d = fns[d.id](...d.args)
      }
      return d
    }
  })
}
13 minutes agoRefactorDiscuss
2 kyu
15x15 Nonogram Solver
Python:
from itertools import groupby
from collections import defaultdict

POS, B = defaultdict(set), 15
f = "{:0>" + str(B) + "b}"
for n in range(1<<B):
    s = f.format(n)
    POS[ tuple(sum(1 for _ in g) for k,g in groupby(s) if k == '1') ].add( tuple(map(int, s)))
    
def solve(clues):
    clues = {'V': clues[0], 'H': clues[1]}
    grid = { (d,z): list(POS[ clues[d][z] ]) for d in 'VH' for z in range(B)}
    
    changed = True
    while changed:
        changed = False
        
        for x in range(B):
            for y in range(B):
            
                tupH, iH, tupV, iV = ('H',x), y, ('V',y), x
                if len(grid[tupH]) == 1 and len(grid[tupV]) == 1: continue
                
                vH = { v[iH] for v in grid[tupH] }
                vV = { v[iV] for v in grid[tupV] }
                target = vH & vV
                
                if len(vH) == 2 and len(target) == 1:
                    changed = True
                    grid[tupH] = [t for t in grid[tupH] if t[iH] in target]
                    
                if len(vV) == 2 and len(target) == 1:
                    changed = True
                    grid[tupV] = [t for t in grid[tupV] if t[iV] in target]
    
    return tuple( grid[('H',n)][0] for n in range(B) )
13 minutes agoRefactorDiscuss
2 kyu
How can I throw an error here?
JavaScript:
function bang() {
  process.emit('error', new this["Er"+"ror"]('Just thr'+'ow like this!'));
}
13 minutes agoRefactorDiscuss
2 kyu
Debugger
Python:
from time import time

class Debugger(object):
  attribute_acceses = []
  method_calls = []

class Meta(type):
  def __new__(cls, name, bases, atts):
    for k,v in atts.items():
      if callable(v): atts[k] = wrapped_method(cls, v)
    atts['__getattribute__'] = wrapped_getattribute(cls) 
    atts['__setattr__'] = wrapped_setattr(cls) 
    return type.__new__(cls, name, bases, atts)

def wrapped_method(c, f):
  def w(*args, **kwargs):
    a = time()
    r = f(*args, **kwargs)
    b = time()
    Debugger.method_calls.append({'class':c,'mehod':f.__name__,'args':args,'kwargs':kwargs,'time':b-a}) 
  return w

def wrapped_setattr(c):
  def s(self, k, v):
    object.__setattr__(self, k, v)
    Debugger.attribute_acceses.append({'action':'set','class':c,'attribute':k,'value':v})
  return s

def wrapped_getattribute(c):
  def g(self, k):
    v = object.__getattribute__(self, k)
    Debugger.attribute_acceses.append({'action':'get','class':c,'attribute':k,'value':v})
    return v
  return g
13 minutes agoRefactorDiscuss
2 kyu
Prime Streaming (NC-17)
JavaScript:
let bitVector = function (size) {
  this.store = new Uint32Array(size);
};
bitVector.prototype.setBit = function (bit) {
  this.store[bit >> 5] |= 1 << (bit & 31);
};
bitVector.prototype.isSet = function (bit) {
  return (this.store[bit >> 5] & (1 << (bit & 31))) !== 0;
};

let maxCheck = 472882240; // make sufficiently high
let sieve = new bitVector((maxCheck >> 5) + 1);

// find all multiples less than maxCheck at the start
// no need to check even numbers
for (let i = 3; i < 32000; i += 2) {
  if (sieve.isSet(i)) continue;
  for (let x = i + i; x <= maxCheck; x += i)
    sieve.setBit(x, true);
}

// A simple Sieve of Eratosthenes with some general coding
// optimizations. Note that this code generates prime numbers
// under a maximal cutoff defined by maxCheck.
class Primes {
  static* stream() {
    yield 2;
    // no need to check even numbers
    for (let i = 3; i <= maxCheck; i += 2)
      if (!sieve.isSet(i))
        yield i;
  }
}
18 minutes agoRefactorDiscuss
2 kyu
Power tower modulo m
Python:
def totient(n):
    n2 = n
    p = 2
    while p * p <= n:
        if n % p == 0:
            n2 = n2 * (p-1) // p
            while n % p == 0: n //= p
        p += 1 + p % 2
    if n > 1:
        n2 = n2 * (n-1) // n
    return n2

from math import log

def tower(base, h, m):
    if m == 1: return 0
    if base == 1 or h == 0: return 1
    # try calculating it directly...
    res = 1
    for _ in range(h):
        if res * log(base) > log(m): break
        res = base ** res
    else: return res % m
    # if it's over m, try numtheory way
    tot = totient(m)
    return pow(base, tot + tower(base, h-1, tot), m)
19 minutes agoRefactorDiscuss
2 kyu
class List
JavaScript:
class Iterable {
  constructor(fn) { this[Symbol.iterator] = fn ; }
  head() { const [r] = this; return r; }
  tail() { const it = this; return new Iterable( function* tail() { yield* it.drop(1); } ); }
  init() { const it = this; return new Iterable( function* init() { let prev=it.head(); for ( const x of it.tail() ) { yield prev; prev = x; } } ); }
  last() { let r; for ( const x of this ) r = x; return r; }
  length() { return this.foldl( z => z+1 , 0 ); }
  toList() { return Array.from(this); }
  get(n) { return this.drop(n).head(); }
  nil() { for ( const x of this ) return false; return true; }
  take(n) { const it = this; return new Iterable( function* take() { let i=n; for ( const x of it ) if ( i-->0 ) yield x; else return; } ); }
  drop(n) { const it = this; return new Iterable( function* drop() { let i=n; for ( const x of it ) if ( i<=0 ) yield x; else i--; } ); }
  cons(x) { const it = this; return new Iterable( function* cons() { yield x; yield* it; } ); }
  append(xs) { const it = this; return new Iterable( function* append() { yield* it; yield* xs; } ); }
  slice(i=0,j=-1) { if ( j>i ) return this.drop(i).take(j-i); else if ( j>=0 ) return Iterable.empty; else return this.drop(i); }
  map(fn) { const it = this; return new Iterable( function* map() { for ( const x of it ) yield fn(x); } ); }
  filter(fn) { const it = this; return new Iterable( function* filter() { for ( const x of it ) if ( fn(x) ) yield x; } ); }
  reverse() { return this.foldl( (z,x) => z.cons(x) , Iterable.empty ); } // this one practically builds a linked list of iterables .. just _can't_ get away from it
  concat() { const it = this; return new Iterable( function* concat() { for ( const xs of it ) yield* xs; } ); }
  concatMap(fn) { return this.map(fn).concat(); }
  zipWith(fn,xs) {
    const it = this;
    return new Iterable( function* zipWith() {
      const dis = it[Symbol.iterator](), dat = xs[Symbol.iterator]();
      for ( let {value,done}=dis.next(), other=dat.next(); ! ( done || other.done ) ; {value,done}=dis.next(), other=dat.next() )
        yield fn( value, other.value );
    } );
  }
  foldr(fn,z) { return fn.length<2 ? this.nil() ? z : fn( this.head() ) : function foldr(it) { return it.nil() ? z : fn( it.head(), foldr(it.tail()) ) ; } ( this ) ; }
  foldl(fn,z) { for ( const x of this ) z = fn(z,x); return z; }
  scanr(fn,z) {
    return fn.length<2
           ? this.map(fn).append([z])
           : function scanr(it) {
               if ( it.nil() )
                 return new Iterable( function* scanr() { yield z; } );
               else {
                 const that = scanr(it.tail());
                 return new Iterable( function* scanr() { yield fn(it.head(),that.head()); yield* that; } );
               }
             } ( this )
           ;
  }
  scanl(fn,z) { const it = this; return new Iterable( function* scanl() { let zz=z; yield zz; for ( const x of it ) yield zz = fn(zz,x); } ); }
  elem(x) { return this.any( y => y===x ); }
  elemIndex(x) { let i=0; for ( const y of this ) if ( y===x ) return i; else i++; return -1; }
  find(fn) { for ( const x of this ) if ( fn(x) ) return x; }
  findIndex(fn) { let i=0; for ( const x of this ) if ( fn(x) ) return i; else i++; return -1; }
  any(fn) { for ( const x of this ) if (   fn(x) ) return true; return false; }
  all(fn) { for ( const x of this ) if ( ! fn(x) ) return false; return true; }
  the() { const [r] = this; for ( const x of this ) if ( x!==r ) return; return r; }
  static iterate(fn,x) { return new Iterable( function* iterate() { for ( let z=x;; z=fn(z) ) yield z; } ); }
  static cycle(xs) { return new Iterable( function* cycle() { while ( true ) yield* xs; } ); }
  static repeat(x) { return new Iterable( function* repeat() { while ( true ) yield x; } ); }
  static replicate(n,x) { return new Iterable( function* replicate() { for ( let i=n; i--; ) yield x; } ); }
  static fromList(xs) { return new Iterable( function* fromList() { yield* xs; } ); }
  static get empty() { return new Iterable( function* empty() {} ); }
  static arctan(x) { return Iterable.iterate( x => -x , 1 ).zipWith( (v,w) => v * x ** w / w , Iterable.iterate( x => x+2 , 1 ) ); }
  static get FIB() {
    let rec = new Iterable( function* FIB() { yield 0; yield 1; yield* rec.zipWith( (v,w) => v+w , rec.tail() ); } );
    return rec;
  }
  static get PRIME() {
    return function sieve(xs) {
      return new Iterable( function* PRIME() { yield* sieve( xs.tail().filter( x => x % xs.head() !== 0 ) ); } ).cons( xs.head() );
    } ( Iterable.iterate( x => x+1 , 2 ) ) ;
  }
  static get PI() { const plus = (v,w) => v+w ; return Iterable.arctan(1/2).scanl(plus,0).zipWith(plus,Iterable.arctan(1/3).scanl(plus,0)).map( v => 4*v ); }
}

const List = Iterable;
19 minutes agoRefactorDiscuss
2 kyu
Yoneda lemma
Haskell:
{-# LANGUAGE RankNTypes, ScopedTypeVariables #-}
module YonedaLemma where
import YonedaLemmaPreloaded
import Data.Functor.Contravariant
import Data.Void

-- Hom(a, b) = all arrows/morphisms from object `a` to object `b`
-- in given category.
-- Hom(a, -) covariant functor:
type Hom a = (->) a

-- natural transformation from functor f to functor g:
type Nat f g = forall x. f x -> g x

-- in order to witness isomorphism
-- we should provide `to` and `from` such, that
-- to . from = id[f a]
-- from . to = id[Nat (Hom a) f]
to :: Functor f => Nat (Hom a) f -> f a
to = ($ id)

from :: Functor f => f a -> Nat (Hom a) f
from = \fa f -> fmap f fa


-- Hom(-, a) contravariant functor:
type CoHom a = Op a
{- NOTE:
Op a b = Op { getOp :: b -> a }

class Contravariant f where
  contramap :: (b -> a) -> f a -> f b
-}

to' :: Contravariant f => Nat (CoHom a) f -> f a
to' = ($ (Op id))

from' :: Contravariant f => f a -> Nat (CoHom a) f
from' = \fa f -> contramap (getOp f) fa


-- now we will try to count the natural transformations

{- in Preloaded we have:
newtype Count x = Count { getCount :: Int } deriving (Show, Eq)
coerce :: Count a -> Count b
class Countable where count :: Count c
class Factor where factor :: Countable c => Count (f c)
instance (Factor f, Countable c) => Countable (f c) where count = factor
-}
-- | NOTE: from here onwards you should imagine `forall x` inside `Count (...)`,
-- | i. e., not `Count ((Numbers -> x) -> Maybe x)`, but `Count (forall x. (Numbers -> x) -> Maybe x)`
-- | we are unable to write it because GHC doesn't yet support impredicative polymorphism (see issue: https://www.codewars.com/kata/yoneda-lemma/discuss/haskell#5b0f4afd3aa7cf7eb100000e)
instance Functor Count where
  fmap = \f -> coerce

count1 :: forall f c x. (Functor f, Factor f, Countable c) => Count ((c -> x) -> f x)
count1 = fmap from factor

count2 :: forall f c x. (Contravariant f, Factor f, Countable c) => Count ((x -> c) -> f x)
count2 = fmap (flip contramap) factor

-- | TIP: you could use types `f`, `c` in RHS of count1 and count2
-- | (because of ScopedTypeVariables pragma and explicit forall)

-- and now i encourage you to count something on fingers ;)
data Numbers = One | Two | Three deriving (Show, Eq)

instance Countable Numbers where
  count = Count 3
 
challenge1 :: Count ((Numbers -> x) -> Maybe x)
challenge1 = Count $ 4

challenge2 :: Count ((Maybe Numbers -> x) -> x)
challenge2 = Count $ 4

challenge3 :: Count ((Numbers -> x) -> (Bool -> x))
challenge3 = Count $ 9

{- Void is a data type without constructors, its declaration:
data Void
Predicate x = Predicate { getPredicate :: x -> Bool }
-- as you might have noticed, Predicate is Contravariant
-}
challenge4 :: Count ((x -> Void) -> Predicate x)
challenge4 = Count $ 1

challenge5 :: Count ((x -> ((Bool -> y) -> (Numbers -> y))) -> (x -> Numbers))
challenge5 = Count $ 6561
19 minutes agoRefactorDiscuss
2 kyu
Tap Into Mr. Mxyzinjin's Brain
JavaScript:
function crack(login) {
  var pw = '';
  while(true) {
    var cands = [...'0123456789'];
    while(cands.length>1) {
      var timing = cands.map(s=>[s,0]);
      for(var r=0; r<3; r++) {
        for(var i=0; i<cands.length; i++) {
          var w = pw+cands[i];
          var t = process.hrtime();
          if(login(w)) return w;
          var s = process.hrtime(t);
          timing[i][1]+=s[1];
        }
      }
      cands = timing.sort((a,b)=>b[1]-a[1]).slice(0,timing.length/2|0).map(e=>e[0]);
    }
    pw += cands[0];
    if(pw.length>32) pw='';
  }
}
20 minutes agoRefactorDiscuss
2 kyu
Hard Sudoku Solver
Python:
from collections import Counter


base = set(range(10))

def validateGrid(lst):
    return (len(lst) == 9 and all(len(r) == 9 for r in lst)
            and noDuplicates(lst)                                                        # rows
            and noDuplicates(zip(*lst))                                                  # cols
            and noDuplicates( [ [lst[x+dx][y+dy] for dx in range(3) for dy in range(3)]
                                for x in range(0,7,3) for y in range(0,7,3)] ))          # squares

def noDuplicates(grid):
    return all( set(c) <= base and (c.__delitem__(0) or set(c.values()) <= {1}) for c in map(Counter, grid))


def sudoku_solver(puzzle):
    if not validateGrid(puzzle): raise ValueError("Invalid grid")
    
    grid = [ [{puzzle[x][y]} if puzzle[x][y] else {1,2,3,4,5,6,7,8,9} for y in range(9)] for x in range(9)]
    sols = set(solveDFS(grid, 0, [[0]*9 for _ in range(9)]))
    
    if len(sols) > 1: raise ValueError("Multiple solutions!")
    if not sols:      raise ValueError("No solution!")
    
    return list(map(list, sols.pop()))
    
    
def solveDFS(grid,cnt,ans):
    
    def filterGridSets(i,j,v,cnt):
    
        a,b = i//3*3, j//3*3                              # Square "entry point"
        for z in range(9):
            for x,y in [(i,z), (z,j), (a+z//3, b+z%3)]:   # in row, in col, in square
                grid[x][y].discard(v)
                if (x,y) != (i,j) and not (len(grid[x][y]) ^ ans[x][y]):
                    return 0                              # Invalid configuration found
                    
        ans[i][j] = v                                     # archive the found number
        return cnt+1
    
    
    change = True
    while cnt != 81 and change:                           # solve as much as possible without guessing
        change = False
        for x in range(9):
            for y in range(9):
                if len(grid[x][y]) == 1:
                    change = True
                    cnt = filterGridSets(x, y, grid[x][y].pop(), cnt)
                    if not cnt: return                    # abort...
    
    
    if cnt == 81: yield tuple(map(tuple, ans))                                                   # found a match
    
    else:
        _,x,y = min((len(s),x,y) for x,row in enumerate(grid) for y,s in enumerate(row) if s)          # peek the shortest non empty set on the grid
        for v in grid[x][y]:
            fresh = [ [s.copy() for s in r] for r in grid]
            fresh[x][y] = {v}
            yield from solveDFS(fresh, cnt, [r[:] for r in ans])
23 minutes agoRefactorDiscuss
2 kyu
Areas of Voronoi cells
JavaScript:
function voronoi_areas(points){
  if (points.length<=3) return Array(points.length).fill(-1)
  points = points.map(({x,y})=>[x,y])

  return points.map(p => {

    let otherPts = points.map(q => ({xy:q,a:angle(p,q)})).sort((a,b) => a.a-b.a)
    otherPts.shift()
    let dists = otherPts.map(q => dist(p, q.xy)), minDi = dists.indexOf(Math.min(...dists))

    otherPts = otherPts.slice(minDi).concat(otherPts.slice(0,minDi)).map(q=>q.xy)
    otherPts.push(otherPts[0])

    let q = otherPts[0], ccs = []
    otherPts.slice(1).forEach(r => {
      if (q == otherPts[0] && r == otherPts[0]) return ccs = []
      if (points.every(s => !inCircle(p,q,r,s))) {
        ccs.push(circumcenter(p,q,r))
        q = r
      }
    })

    let area = ccs.reduce((ttl, cc, j) => {
      let [px,py] = p, [qx,qy] = cc, [rx,ry] = ccs[j+1] || ccs[0]
      return ttl + (px * (qy - ry) + qx * (ry - py) + rx * (py - qy)) / 2
    },0) || -1
    return area < 1 ? -1 : area
  })
}

function angle(a,b){
  if (a==b) return -1
  let [dx, dy] = [0,1].map(c => a[c] - b[c]), p = dx / (Math.abs(dx) + Math.abs(dy))
  return (dy > 0 ? 3 - p : 1 + p) / 4
}

function dist([ax, ay], [bx, by]) {
  return Math.pow(ax-bx,2) + Math.pow(ay-by,2)
}

function inCircle ([ax, ay], [bx, by], [cx, cy], [px, py]) {
  let dx = ax-px, dy = ay-py, ex = bx-px, ey = by-py, fx = cx-px, fy = cy-py
  return (dx*dx + dy*dy) * (ex*fy-fx*ey) - (ex*ex + ey*ey) * (dx*fy-fx*dy) + (fx*fx + fy*fy) * (dx*ey-ex*dy) > 1e-10
}

function circumcenter([ax, ay], [bx, by], [cx, cy]) {
  let dx = bx-ax, dy = by-ay, ex = cx-ax, ey = cy-ay, bl = dx*dx + dy*dy, cl = ex*ex + ey*ey, d = 0.5 / (dx*ey - dy*ex)
  return [ax + (ey*bl - dy*cl) * d, ay + (dx*cl - ex*bl) * d]
}
23 minutes agoRefactorDiscuss
2 kyu
Count them all!
Haskell:
{-# LANGUAGE FlexibleInstances, UndecidableInstances #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Counting where
import Counting.Preloaded
import Data.Proxy
import Data.Void
import Data.Functor.Const
import Data.Functor.Identity
import Data.Functor.Sum
import Data.Functor.Product
import Data.Functor.Compose

{- in Preloaded:
data Nat = Z | S Nat deriving (Show, Eq, Ord)
instance Num Nat -- so (2 :: Nat) == S (S Z)
instance Enum Nat -- so ([0..3] :: [Nat]) == [Z, S Z, S (S Z)]
instance Real Nat
instance Integral Nat -- so (2 ^ 3 :: Nat) == S (S (S (S (S (S (S (S Z)))))))
-}

-- The countably infinite
infinity :: Nat
infinity = S infinity

newtype Count x = Count { getCount :: Nat } deriving (Show, Eq, Ord)

-- | helper functions
mapC :: (Nat -> Nat) -> Count a -> Count b
mapC f (Count a) = Count $ f a

liftC2 :: (Nat -> Nat -> Nat) -> Count a -> Count b -> Count c
liftC2 f (Count a) (Count b) = Count $ f a b

coerceC :: Count a -> Count b
coerceC (Count n) = Count n

-- | Countable
class Countable c where
  count :: Count c
  -- if you are using `Proxy` implement `count` from `count'` and vice versa
  count = count' Proxy
  count' :: Proxy c -> Count c
  count' Proxy = count
  
instance Countable Void where count = Count 0
instance Countable () where count = Count 1
instance Countable Bool where count = Count 2
instance Countable Nat where count = Count infinity

-- | Factor
class Factor f where
  factor :: Count c -> Count (f c)
  factor' :: Proxy f -> Count c -> Count (f c) -- optional
  factor' Proxy count = factor count

instance (Factor f, Countable c) => Countable (f c) where
  count = factor count

instance Factor Maybe where factor (Count n) = Count $ n + 1
instance Factor Identity where factor = coerceC
instance Factor Proxy where factor _ = Count 1
instance Factor Count where factor _ = Count infinity
instance Factor [] where factor (Count n) = Count $ if n == 0 then 1 else infinity
instance Countable c => Factor (Const c) where factor _ = coerceC (count :: Count c)
instance Countable c => Factor (Either c) where factor (Count n) = Count $ getCount (count :: Count c) + n
instance Countable c => Factor ((,) c) where factor (Count n) = Count $ getCount (count :: Count c) * n
instance Countable c => Factor ((->) c) where factor (Count n) = Count $ n ^ getCount (count :: Count c)
instance (Factor f, Factor g) => Factor (Sum f g) where factor (countN :: Count c) = liftC2 (+) (factor countN :: Count (f c)) (factor countN :: Count (g c))
instance (Factor f, Factor g) => Factor (Product f g) where factor (countN :: Count c) = liftC2 (*) (factor countN :: Count (f c)) (factor countN :: Count (g c))
instance (Factor f, Factor g) => Factor (Compose f g) where factor (countN :: Count c) = coerceC (factor (factor countN :: Count (g c)) :: Count (f (g c)))

-- | Listable
class Countable a => Listable a where
  list :: [a]
  list' :: Proxy a -> [a] -- optional
  list' Proxy = list
-- Data.List.genericLength (list :: [a]) `shouldBe` getCount (count :: Count a)

instance Listable Void where list = []
instance Listable () where list = [()]
instance Listable Bool where list = [True, False]
instance Listable Nat where list = Z : map S list

instance Listable c => Listable (Maybe c) where list = Nothing : map Just list
instance Listable c => Listable [c] where
  list = [] : do
    x <- list :: [c]
    map (x :) (list :: [[c]])
instance (Listable a, Listable b) => Listable (Either a b) where list = map Left list ++ map Right list
instance (Listable a, Listable b) => Listable (a, b) where
  list = do
    x <- list :: [a]
    map ((,) x) (list :: [b])
instance (Eq a, Listable a, Listable b) => Listable (a -> b) where
  list = foldl (\fs x -> do
    y <- list :: [b]
    map (\f x' -> if x' == x
      then y
      else f x') fs) [undefined] (list :: [a])
25 minutes agoRefactorDiscuss
2 kyu
Blaine is a pain
Java:
import java.awt.Point;
import java.util.*;
import java.util.stream.*;

public class Dinglemouse {

    public static int trainCrash(final String track, final String aTrain, final int aTrainPos, final String bTrain, final int bTrainPos, final int limit) {
        return new BlaimHim(track, aTrain, aTrainPos, bTrain, bTrainPos, limit).crash();
  }
}


class BlaimHim {
    
    final private static Map<Character, Point[][]> MOVES = new HashMap<Character,Point[][]>() {{            // Only for the corners
        put('/',  new Point[][] {new Point[] {new Point( 0,-1), new Point( 1,-1), new Point(1, 0)},         // Coming from up-right, goes down-left...
                                 new Point[] {new Point(-1, 0), new Point(-1, 1), new Point(0, 1)}});       // ...coming from down-left, goes up-right. Elt[0] when x-y > 0, elt[1] otherwise
        put('\\', new Point[][] {new Point[] {new Point( 0, 1), new Point( 1, 1), new Point(1, 0)},         // Coming from up-left, goes down-right...
                                 new Point[] {new Point(-1, 0), new Point(-1,-1), new Point(0,-1)}});       // ...coming from down-right, goes up-left. Elt[0] when x+y > 0, elt[1] otherwise
    }};
    final private static Map<Character, char[][]> TARGET_CHAR = new HashMap<Character,char[][]>() {{        // Corresponding target character, when leaving the "turn"
        put('/',  new char[][] {new char[] {'-', '/',  '|'}, new char[] {'|', '/',  '-'}});
        put('\\', new char[][] {new char[] {'-', '\\', '|'}, new char[] {'|', '\\', '-'}});
    }};
    
    private List<Train> trains;
    private Track[]     tracks;
    private int         limit;
    
    
    public BlaimHim(final String track, final String aTrain, final int aPos, final String bTrain, final int bPos, final int limit) {
        this.limit = limit;
        trackBuilder(track);                                                    // Build the tracks array
        trains = Arrays.asList(new Train(aPos, aTrain, tracks),                 // Build the trains list
                               new Train(bPos, bTrain, tracks));
    }
    
    
    private void trackBuilder(String track) {
        
        Stream.Builder<Track> sBuild = Stream.builder();                        // Accumulate the Track instances that represent the track path
        Map<Point,Track> toLink = new HashMap<>();                              // Prepare the archive to link the Track instances together
        char[][] arr = Arrays.stream(track.split("\n",-1))                      // Convert the track string to a char array to facilitate the path following
                              .map( s -> s.toCharArray() )
                              .toArray(char[][]::new);
        
        Point move = new Point(0,1),                                            // Starting moving direction
              pos  = new Point(0, IntStream.range(0,arr[0].length)              // Define the starting position
                                           .filter( n -> arr[0][n] != ' ' && arr[0][n] != '\n' )
                                           .findFirst()
                                           .getAsInt()),
              start = new Point(pos);
        
        for (int p = 0 ; true ; p++) {
            char  c = arr[pos.x][pos.y];
            Track t = new Track(pos.x, pos.y, c);
            
            if ("+XS".contains(""+c)) {
                if (toLink.containsKey(pos)) t = toLink.get(pos);               // If the current position has already been archived, will push a reference of the original Track object at this position in the array
                else                         toLink.put(pos, t);                // Archive the Track instance
            }
            sBuild.accept(t);                                                   // Push the Track instance in the builder
            
            if (p != 0 && (c == '/' || c == '\\')) {                            // Might need an update for the direction, here
                int   idx        = getIndexRelativeToMove(c, move);
                final Point   pp = new Point(pos);
                final Point[] m  = MOVES.get(c)[idx];
                final char[]  tc = TARGET_CHAR.get(c)[idx];
                move = IntStream.range(0,3)
                                .filter( i ->    0 <= pp.x+m[i].x && pp.x+m[i].x < arr.length
                                              && 0 <= pp.y+m[i].y && pp.y+m[i].y < arr[pp.x+m[i].x].length
                                              && ("XS"+tc[i]).contains( ""+arr[pp.x+m[i].x][pp.y+m[i].y] ) )
                                .mapToObj( i -> m[i] )
                                .findFirst()
                                .get();
            }
            pos = new Point(pos.x+move.x, pos.y+move.y);
            if (pos.equals(start)) break;
        }
        tracks = sBuild.build().toArray(Track[]::new);                          // Actually build the tracks array
    }
        
    private int getIndexRelativeToMove(char c, Point m) {                       // Determine the index to use in the constant map MOVES
        return c == '/' ? ( m.x-m.y > 0 ? 0:1 )
                        : ( m.x+m.y > 0 ? 0:1 );
    }
    
    
    public int crash() {
        for (int round = 0; round <= limit ; round++) {
            if (trains.stream().anyMatch( t -> t.checkEatItSelf()) || trains.get(0).checkCrashWith(trains.get(1)) )
                return round;
            trains.stream().forEach( t -> t.move() );
        }
        return -1;
    }
}


class Track extends Point {
    
    protected Track   linkedTo = null;
    protected boolean isStation;
    protected char    c;
    
    public Track(int x, int y, char c) {
        super(x,y);
        isStation = c=='S';
        this.c = c;
    }
    @Override public String toString() { return ""+c; }
}


class Train {
    
    protected Track[]    tracks;
    protected boolean    isXpress;
    protected int        pos, dir, len, delay = 0;
    protected char       c;
    protected Set<Track> occupy;
    
    public Train(int pos, String s, Track[] tracks) {
        this.pos      = pos;
        this.dir      = Character.isUpperCase(s.charAt(0)) ? -1 : 1;
        this.len      = s.length();
        this.isXpress = Character.toLowerCase(s.charAt(0)) == 'x';
        this.tracks   = tracks;
        this.c        = s.charAt(0);
        updateOccupy();
    }
    
    private void updateOccupy() {
        occupy = IntStream.range(0,len)
                          .map( x -> (pos - dir*x + tracks.length) % tracks.length )
                          .mapToObj( i -> tracks[i] )
                          .collect(Collectors.toSet());
    }
    public void move() {
        if (delay != 0) delay--;
        else {          pos   = (pos + dir + tracks.length) % tracks.length;
                        delay = tracks[pos].isStation && !isXpress ? len-1 : 0;
        }
        updateOccupy();
    }
    public boolean checkEatItSelf()        { return occupy.size() != len; }
    public boolean checkCrashWith(Train o) { return occupy.stream().anyMatch( t -> o.occupy.contains(t) ); }  
}
26 minutes agoRefactorDiscuss

import java.awt.Point;
import java.util.*;
import java.util.stream.*;

public class Dinglemouse {

    public static int trainCrash(final String track, final String aTrain, final int aTrainPos, final String bTrain, final int bTrainPos, final int limit) {
        return new BlaimHim(track, aTrain, aTrainPos, bTrain, bTrainPos, limit).crash();
  }
}


class BlaimHim {
    
    final private static Map<Character, Point[][]> MOVES = new HashMap<Character,Point[][]>() {{            // Only for the corners
        put('/',  new Point[][] {new Point[] {new Point( 0,-1), new Point( 1,-1), new Point(1, 0)},         // Coming from up-right, goes down-left...
                                 new Point[] {new Point(-1, 0), new Point(-1, 1), new Point(0, 1)}});       // ...coming from down-left, goes up-right. Elt[0] when x-y > 0, elt[1] otherwise
        put('\\', new Point[][] {new Point[] {new Point( 0, 1), new Point( 1, 1), new Point(1, 0)},         // Coming from up-left, goes down-right...
                                 new Point[] {new Point(-1, 0), new Point(-1,-1), new Point(0,-1)}});       // ...coming from down-right, goes up-left. Elt[0] when x+y > 0, elt[1] otherwise
    }};
    final private static Map<Character, char[][]> TARGET_CHAR = new HashMap<Character,char[][]>() {{        // Corresponding target character, when leaving the "turn"
        put('/',  new char[][] {new char[] {'-', '/',  '|'}, new char[] {'|', '/',  '-'}});
        put('\\', new char[][] {new char[] {'-', '\\', '|'}, new char[] {'|', '\\', '-'}});
    }};
    
    private List<Train> trains;
    private Track[]     tracks;
    private int         limit;
    
    
    public BlaimHim(final String track, final String aTrain, final int aPos, final String bTrain, final int bPos, final int limit) {
        this.limit = limit;
        trackBuilder(track);                                                    // Build the tracks array
        trains = Arrays.asList(new Train(aPos, aTrain, tracks),                 // Build the trains list
                               new Train(bPos, bTrain, tracks));
    }
    
    
    private void trackBuilder(String track) {
        
        Stream.Builder<Track> sBuild = Stream.builder();                        // Accumulate the Track instances that represent the track path
        Map<Point,Track> toLink = new HashMap<>();                              // Prepare the archive to link the Track instances together
        char[][] arr = Arrays.stream(track.split("\n",-1))                      // Convert the track string to a char array to facilitate the path following
                              .map( s -> s.toCharArray() )
                              .toArray(char[][]::new);
        
        Point move = new Point(0,1),                                            // Starting moving direction
              pos  = new Point(0, IntStream.range(0,arr[0].length)              // Define the starting position
                                           .filter( n -> arr[0][n] != ' ' && arr[0][n] != '\n' )
                                           .findFirst()
                                           .getAsInt()),
              start = new Point(pos);
        
        for (int p = 0 ; true ; p++) {
            char  c = arr[pos.x][pos.y];
            Track t = new Track(pos.x, pos.y, c);
            
            if ("+XS".contains(""+c)) {
                if (toLink.containsKey(pos)) t = toLink.get(pos);               // If the current position has already been archived, will push a reference of the original Track object at this position in the array
                else                         toLink.put(pos, t);                // Archive the Track instance
            }
            sBuild.accept(t);                                                   // Push the Track instance in the builder
            
            if (p != 0 && (c == '/' || c == '\\')) {                            // Might need an update for the direction, here
                int   idx        = getIndexRelativeToMove(c, move);
                final Point   pp = new Point(pos);
                final Point[] m  = MOVES.get(c)[idx];
                final char[]  tc = TARGET_CHAR.get(c)[idx];
                move = IntStream.range(0,3)
                                .filter( i ->    0 <= pp.x+m[i].x && pp.x+m[i].x < arr.length
                                              && 0 <= pp.y+m[i].y && pp.y+m[i].y < arr[pp.x+m[i].x].length
                                              && ("XS"+tc[i]).contains( ""+arr[pp.x+m[i].x][pp.y+m[i].y] ) )
                                .mapToObj( i -> m[i] )
                                .findFirst()
                                .get();
            }
            pos = new Point(pos.x+move.x, pos.y+move.y);
            if (pos.equals(start)) break;
        }
        tracks = sBuild.build().toArray(Track[]::new);                          // Actually build the tracks array
    }
        
    private int getIndexRelativeToMove(char c, Point m) {                       // Determine the index to use in the constant map MOVES
        return c == '/' ? ( m.x-m.y > 0 ? 0:1 )
                        : ( m.x+m.y > 0 ? 0:1 );
    }
    
    
    public int crash() {
        for (int round = 0; round <= limit ; round++) {
            if (trains.stream().anyMatch( t -> t.checkEatItSelf()) || trains.get(0).checkCrashWith(trains.get(1)) )
                return round;
            trains.stream().forEach( t -> t.move() );
        }
        return -1;
    }
}


class Track extends Point {
    
    protected Track   linkedTo = null;
    protected boolean isStation;
    protected char    c;
    
    public Track(int x, int y, char c) {
        super(x,y);
        isStation = c=='S';
        this.c = c;
    }
    @Override public String toString() { return ""+c; }
}


class Train {
    
    protected Track[]    tracks;
    protected boolean    isXpress;
    protected int        pos, dir, len, delay = 0;
    protected char       c;
    protected Set<Track> occupy;
    
    public Train(int pos, String s, Track[] tracks) {
        this.pos      = pos;
        this.dir      = Character.isUpperCase(s.charAt(0)) ? -1 : 1;
        this.len      = s.length();
        this.isXpress = Character.toLowerCase(s.charAt(0)) == 'x';
        this.tracks   = tracks;
        this.c        = s.charAt(0);
        updateOccupy();
    }
    
    private void updateOccupy() {
        occupy = IntStream.range(0,len)
                          .map( x -> (pos - dir*x + tracks.length) % tracks.length )
                          .mapToObj( i -> tracks[i] )
                          .collect(Collectors.toSet());
    }
    public void move() {
        if (delay != 0) delay--;
        else {          pos   = (pos + dir + tracks.length) % tracks.length;
                        delay = tracks[pos].isStation && !isXpress ? len-1 : 0;
        }
        updateOccupy();
    }
    public boolean checkEatItSelf()        { return occupy.size() != len; }
    public boolean checkCrashWith(Train o) { return occupy.stream().anyMatch( t -> o.occupy.contains(t) ); }  
}
2 hours agoRefactor
2 kyu
Ludicrous Coloured Triangles
JavaScript:
function triangle(row) {
  /* Returns the result of the combination of two colours. 
     Note that inputs and output are all integers (0, 1, and 2), not letters (R, G, and B).
   */
  function combine(a, b) {
    return (a === b) ? a : (3-a-b);
  }

  /* Returns the greatest power of 3 less than or equal to n. */
  function pow3(n) {
   /*
     This is the most straightforward implementation (it computes iterative 
     multiplications by 3 for each and every call).
     But interestingly enough it runs super fast on the current platform. A lot 
     faster, for instance, than another one I tried using an array of pre-computed powers.
   */
    let i= 1, j= 1;
    while (i <= n) {
      j= i;
      i*= 3;
    }
    return j;
  }
  
  /* Recursive function computing the *offset*th colour on the *level*th row */
  function rec(level, offset) {
    /*
       The technique here comes from the observation that for a string of 4 colours (3+1), 
       only the ends actually have an influence on the result. The two colours in the 
       middle of the string have no impact at all. More precisely: 
       - RxxR always gives R (and GxxG gives G, and BxxB gives B),
       - RxxG always gives B (and this is symetrical for other combinations).
       This obviously scales up: a string of 10 colours (3*3+1) is like 4 times a string
       of 4 (with combined ends), so again only the ends have an impact... and so on for 
       every power of 3 plus 1.
       This property allows to compute large strings very efficiently by ignoring a large 
       part of the input and focusing only on the few chunks that have an actual influence 
       on the final result.
     */
    if (!level) {
      /*
         In order to speed things up, we use integers (0, 1, 2) instead of 
         letters for the whole computation. Letters are transformed into indexes 
         only for the first row (level == 0).
       */
      switch (row[offset]) {
      case 'R': return 0;
      case 'G': return 1;
      default: return 2;
      }
    }
    const step= pow3(level);
    return combine(rec(level-step, offset), rec(level-step, offset+step));
  }

  if (!row) return '';
  /* Launch the computation, and convert the result back to a letter */
  return "RGB"[rec(row.length-1, 0)];
}
26 minutes agoRefactorDiscuss
2 kyu
Symbolic differentiation of prefix expressions
JavaScript:
const DEBUG = false ;

const diff = expr => show(optimise(evaluate(parse(tokenise(expr))))) ;

const tokenise = expression => DEBUG && console.log("<hr>tokenise",expression) ||
  ( expression.match( /-?(\d*\.)?\d+|\w+|[-+/*^]/g ) || [] ).map( t => isNumber(t) ? Number(t) : t )
;

const parse = tokens => { DEBUG && console.log("<hr>parse",tokens);
  const doOp = (op,left,right) => new Node(op,left,right) ;
  const accept = s => [...s].some( v => v===tokens[0] ) && tokens.shift();
  const variable = () => doOp(tokens.shift()) ;
  const constant = () => isNumber(tokens[0]) ? tokens.shift() : variable() ;
  const binary = (op) => ( op = accept(BINARY) ) ? doOp(op,expr(),expr()) : constant() ;
  const expr = (op) => ( op = accept(UNARY) ) ? doOp(op,expr()) : binary() ;
  return expr();
};

const evaluate = node => DEBUG && console.log("<hr>evaluate",show(node)) ||
  isNumber(node)           ? 0 :
  BINARY.includes(node.op) ? [ node => new Node(node.op,evaluate(node.left),evaluate(node.right)),
                               node => new Node(node.op,evaluate(node.left),evaluate(node.right)),
                               node => new Node(node.op,new Node("-",new Node("*",evaluate(node.left),node.right),new Node("*",node.left,evaluate(node.right))),new Node("^",node.right,2)),
                               node => new Node("+",new Node("*",evaluate(node.left),node.right),new Node("*",node.left,evaluate(node.right))),
                               node => new Node("*",evaluate(node.left),new Node("*",node.right,new Node(node.op,node.left,new Node("-",node.right,1)))),
                             ] [BINARY.indexOf(node.op)] (node) :
  UNARY.includes(node.op)  ? [ node => new Node("*",evaluate(node.left),new Node("cos",node.left)),
                               node => new Node("*",evaluate(node.left),new Node("*",-1,new Node("sin",node.left))),
                               node => new Node("*",evaluate(node.left),new Node("+",1,new Node("^",node,2))),
                               node => new Node("*",evaluate(node.left),node),
                               node => new Node("*",evaluate(node.left),new Node("/",1,node.left)),
                             ] [UNARY.indexOf(node.op)] (node) :
  /* variable */             1
;

const optimise = node => DEBUG && console.log("<hr>optimise",show(node)) ||
  BINARY.includes(node.op) ? [ left => right => isNumber(left) && isNumber(right) ? left-right : right===0 ? left : new Node(node.op,left,right) ,
                               left => right => isNumber(left) && isNumber(right) ? left+right : left===0 ? right : right===0 ? left : new Node(node.op,left,right)  ,
                               left => right => isNumber(left) && isNumber(right) ? left/right : left===0 ? 0 : right===1 ? left : new Node(node.op,left,right) ,
                               left => right => isNumber(left) && isNumber(right) ? left*right : left===0 || right===0 ? 0 : left===1 ? right : right===1 ? left : new Node(node.op,left,right) ,
                               left => right => isNumber(left) && isNumber(right) ? Math.pow(left,right) : left===0 ? 0 : left===1 ? 1 : right===0 ? 1 : right===1 ? left : new Node(node.op,left,right) ,
                             ] [BINARY.indexOf(node.op)] (optimise(node.left)) (optimise(node.right)) :
  UNARY.includes(node.op)  ? new Node(node.op,optimise(node.left)) :
  /* number or variable */ node
;

const show = node =>
  isNumber(node)           ? `${node}` :
  BINARY.includes(node.op) ? `(${node.op} ${show(node.left)} ${show(node.right)})` :
  UNARY.includes(node.op)  ? `(${node.op} ${show(node.left)})` :
  /* variable */             `${node.op}`
;

function Node(op,left,right) {
  this.op = op;
  this.left = left;
  this.right = right;
}

const isNumber = t => Number.isFinite(Number(t)) ;
const BINARY = "-+/*^";
const UNARY = ["sin","cos","tan","exp","ln"];
29 minutes agoRefactorDiscuss
2 kyu
Odd + Even = Odd? Prove it!
Haskell:
{-# LANGUAGE GADTs, DataKinds,
             TypeFamilies, UndecidableInstances #-}

module OddsAndEvens where

-- | The natural numbers.
data Nat = Z | S Nat

-- | The axioms of even numbers.
data Even (a :: Nat) :: * where
  -- | Zero is even.
  ZeroEven :: Even Z
  -- | If n is even, then n+2 is even.
  NextEven :: Even n -> Even (S (S n))

-- | The axioms of odd numbers.
data Odd (a :: Nat) :: * where
  -- | One is odd.
  OneOdd :: Odd (S Z)
  -- | If n is odd, then n+2 is odd.
  NextOdd :: Odd n -> Odd (S (S n))

-- | Proves that if n is even, n+1 is odd.
-- Notice how I use the axioms here.
evenPlusOne :: Even n -> Odd (S n)
evenPlusOne ZeroEven = OneOdd
evenPlusOne (NextEven n) = NextOdd (evenPlusOne n)

-- | Proves that if n is odd, n+1 is even.
oddPlusOne :: Odd n -> Even (S n)
oddPlusOne OneOdd = NextEven ZeroEven
oddPlusOne (NextOdd n) = NextEven(oddPlusOne n)

-- | Adds two natural numbers together.
-- Notice how the definition pattern matches.
type family   Add (n :: Nat) (m :: Nat) :: Nat
type instance Add Z m = m
type instance Add (S n) m = S (Add n m)

-- | Proves even + even = even
-- Notice how the pattern matching mirrors `Add`s definition.
evenPlusEven :: Even n -> Even m -> Even (Add n m)
evenPlusEven ZeroEven m = m
evenPlusEven (NextEven n) m = NextEven (evenPlusEven n m)

-- | Proves odd + odd = even
oddPlusOdd :: Odd n -> Odd m -> Even (Add n m)
oddPlusOdd OneOdd m = oddPlusOne m
oddPlusOdd (NextOdd n) m = NextEven (oddPlusOdd n m)

-- | Proves even + odd = odd
evenPlusOdd :: Even n -> Odd m -> Odd (Add n m)
evenPlusOdd ZeroEven m = m
evenPlusOdd (NextEven n) m = NextOdd (evenPlusOdd n m)

-- | Proves odd + even = odd
oddPlusEven :: Odd n -> Even m -> Odd (Add n m)
oddPlusEven OneOdd m = evenPlusOne m
oddPlusEven (NextOdd n) m = NextOdd (oddPlusEven n m)

-- | Multiplies two natural numbers.
type family   Mult (n :: Nat) (m :: Nat) :: Nat
type instance Mult Z m = Z
type instance Mult (S n) m = Add (Mult n m) m

-- | Proves even * even = even
evenTimesEven :: Even n -> Even m -> Even (Mult n m)
evenTimesEven ZeroEven m = ZeroEven
evenTimesEven (NextEven n) m = evenPlusEven (oddTimesEven (evenPlusOne n) m) m

-- | Proves odd * odd = odd
oddTimesOdd :: Odd n -> Odd m -> Odd (Mult n m)
oddTimesOdd OneOdd m = m
oddTimesOdd (NextOdd n) m = evenPlusOdd (evenTimesOdd (oddPlusOne n) m) m

-- | Proves even * odd = even
evenTimesOdd :: Even n -> Odd m -> Even (Mult n m)
evenTimesOdd ZeroEven m = ZeroEven
evenTimesOdd (NextEven n) m = oddPlusOdd (oddTimesOdd (evenPlusOne n) m) m

-- | Proves odd * even = even
oddTimesEven :: Odd n -> Even m -> Even (Mult n m)
oddTimesEven OneOdd m = m
oddTimesEven (NextOdd n) m = evenPlusEven (evenTimesEven (oddPlusOne n) m) m
29 minutes agoRefactorDiscuss
2 kyu
Transforming Maze Solver
JavaScript:
function mazeSolver(maze){
  const canMove = (item, dir, iteration) => {
    if (item.x + dir.x < 0 || item.x + dir.x >= m) return false;
    if (item.y + dir.y < 0 || item.y + dir.y >= n) return false;
    
    const ownWalls = maze[item.y][item.x];
    const nextCellWalls = maze[item.y + dir.y][item.x + dir.x];
    const canLeave = (ownWalls & (1 << ((4 + dir.bit - iteration % 4) %4))) === 0;
    const canEnter = (nextCellWalls & (1 << ((4 + 2 + dir.bit - iteration % 4) %4))) === 0;
    
    return canLeave && canEnter;
  }

  const m = maze[0].length;
  const n = maze.length;
  
  const start = {x: 0, y: 0};
  const end = {x: 0, y: 0};
  let path = null;
  
  maze.forEach((row, i) => {
    row.forEach((column, j) => {
      if (column === 'B') {
        start.x = j;
        start.y = i;
        row[j] = 0;
      }
      
      if (column === 'X') {
        end.x = j;
        end.y = i;
        row[j] = 0;
      }
    })
  });
  
  const visited = {};
  const queue = [[{...start, path: [''], iteration: 0}], []];
  
  const addToPath = (path, direction) =>
    [...path.slice(0, -1), path[path.length-1]+direction];
  
  const processItem = (item) => {
    if (item.x < 0 || item.x > m) return;
    if (item.y < 0 || item.y > n) return;
    if (item.x === end.x && item.y === end.y) {
      path = item.path;
      return;
    }
    
    if (visited['' + item.x + ',' + item.y + ',' + item.iteration % 4]) {
      return;
    }
    
    visited['' + item.x + ',' + item.y + ',' + item.iteration % 4] = true;
    
    if (canMove(item, {x: -1, y: 0, bit: 2}, item.iteration))
      queue[0].push({...item, x: item.x - 1, path: addToPath(item.path, 'W')});
    
    if (canMove(item, {x: 1, y: 0, bit: 0}, item.iteration))
      queue[0].push({...item, x: item.x + 1, path: addToPath(item.path, 'E')});
      
    if (canMove(item, {x: 0, y: -1, bit: 3}, item.iteration))
      queue[0].push({...item, y: item.y - 1, path: addToPath(item.path, 'N')});
      
    if (canMove(item, {x: 0, y: 1, bit: 1}, item.iteration))
      queue[0].push({...item, y: item.y + 1, path: addToPath(item.path, 'S')});
      
    if (queue.length === 1) {
      queue.push([]);
    }
    
    queue[1].push({...item, path: [...item.path, ''], iteration: item.iteration + 1});
  }
  
  while (queue.length && !path) {
    while(queue[0].length && !path) {
      processItem(queue[0].shift());
    }
    queue.shift();
  }

  return path;
}
30 minutes agoRefactorDiscuss

function mazeSolver(maze){
  const canMove = (item, dir, iteration) => {
    if (item.x + dir.x < 0 || item.x + dir.x >= m) return false;
    if (item.y + dir.y < 0 || item.y + dir.y >= n) return false;
    
    const ownWalls = maze[item.y][item.x];
    const nextCellWalls = maze[item.y + dir.y][item.x + dir.x];
    const canLeave = (ownWalls & (1 << ((4 + dir.bit - iteration % 4) %4))) === 0;
    const canEnter = (nextCellWalls & (1 << ((4 + 2 + dir.bit - iteration % 4) %4))) === 0;
    
    return canLeave && canEnter;
  }

  const m = maze[0].length;
  const n = maze.length;
  
  const start = {x: 0, y: 0};
  const end = {x: 0, y: 0};
  let path = null;
  
  maze.forEach((row, i) => {
    row.forEach((column, j) => {
      if (column === 'B') {
        start.x = j;
        start.y = i;
        row[j] = 0;
      }
      
      if (column === 'X') {
        end.x = j;
        end.y = i;
        row[j] = 0;
      }
    })
  });
  
  const visited = {};
  const queue = [[{...start, path: [''], iteration: 0}], []];
  
  const addToPath = (path, direction) =>
    [...path.slice(0, -1), path[path.length-1]+direction];
  
  const processItem = (item) => {
    if (item.x < 0 || item.x > m) return;
    if (item.y < 0 || item.y > n) return;
    if (item.x === end.x && item.y === end.y) {
      path = item.path;
      return;
    }
    
    if (visited['' + item.x + ',' + item.y + ',' + item.iteration % 4]) {
      return;
    }
    
    visited['' + item.x + ',' + item.y + ',' + item.iteration % 4] = true;
    
    if (canMove(item, {x: -1, y: 0, bit: 2}, item.iteration))
      queue[0].push({...item, x: item.x - 1, path: addToPath(item.path, 'W')});
    
    if (canMove(item, {x: 1, y: 0, bit: 0}, item.iteration))
      queue[0].push({...item, x: item.x + 1, path: addToPath(item.path, 'E')});
      
    if (canMove(item, {x: 0, y: -1, bit: 3}, item.iteration))
      queue[0].push({...item, y: item.y - 1, path: addToPath(item.path, 'N')});
      
    if (canMove(item, {x: 0, y: 1, bit: 1}, item.iteration))
      queue[0].push({...item, y: item.y + 1, path: addToPath(item.path, 'S')});
      
    if (queue.length === 1) {
      queue.push([]);
    }
    
    queue[1].push({...item, path: [...item.path, ''], iteration: item.iteration + 1});
  }
  
  while (queue.length && !path) {
    while(queue[0].length && !path) {
      processItem(queue[0].shift());
    }
    queue.shift();
  }

  return path;
}
2 hours agoRefactor
2 kyu
Cut the cake
JavaScript:
const cut = cake => {
  const num = cake.match(/o/g).length;  
  const cakeArray = cake.split('\n').map(e => e.split``);
  const rows = cakeArray.length;
  const cols = cakeArray[0].length;
  const size = (rows * cols) / num;
  return run(cakeArray, size, []);
}

const run = (cake, size, slices) => {
  const corner = findFirstTopLeftCorner(cake);
  if (null == corner) return slices;
  let x = corner[1];
  let y = corner[0];

  for (let width = size; width >= 1; width--) {
    for (let height = 1; height <= size; height++) {
      if ((height * width) !== size) continue;
      const slice = isAValidSlice(cake, x, y, width, height);
      if (!slice) continue;
      const newSlices = Object.assign([], slices);
      newSlices.push(slice);
      let newCake = doCut(JSON.parse(JSON.stringify(cake)), x, y, width, height);
      let r = run(newCake, size, newSlices);
      if (r.length) return r;
    }
  }

  return [];
}

const findFirstTopLeftCorner = cake => {
  for (let i = 0; i < cake.length; i++) 
    for (let j = 0; j < cake[i].length; j++) 
      if (cake[i][j] !== 'x') 
        return [i,j];
}

const isAValidSlice = (cake, x, y, width, height) => {
  if ((x + width) > cake[0].length) return false;
  if ((y + height) > cake.length) return false;
  const slice = cake.slice(y, y + height).map(e => e.slice(x, x + width));
  const sliceStr = stringify(slice);  
  if (sliceStr.match(/x/)) return false;
  const numberOfO = (sliceStr.match(/o/g) || []).length;
  if (numberOfO !== 1) return false;
  return sliceStr;
}

const stringify = cake => cake.map(e => e.join``).join`\n`;

const doCut = (cake, x, y, width, height) => {
  for (let i = y; i < (y + height); i++) 
    for (let j = x; j < (x + width); j++) 
      cake[i][j] = 'x';
  return cake;
}
31 minutes agoRefactorDiscuss
2 kyu
One Line Task: Circle Intersection
JavaScript:
circleIntersection=([a,b],[c,d],r)=>(m=Math,-m.sin(x=2*m.acos(m.hypot(a-c,b-d)/2/r))+x)*r*r|0
31 minutes agoRefactorDiscuss
2 kyu
Expression Transpiler
JavaScript:
function transpile(program) {
  const func = () => {
    const name = expr()
    const args = []
    if (eat("(")) {
      if (!eat(")")) {
        args.push(expr())
        while (!eat(")")) {
          expect(",")
          args.push(expr())
        }
      }
      if (match("{")) {
        args.push(lambda())
      }
    } else {
      args.push(lambda())
    }
    return `${name}(${args.join(",")})`
  }
  const expr = () => match("{") ? lambda() : value()
  const value = () => /^\w+$/.test(tokens[0]) ? tokens.shift() : expect("a name or a number")
  const lambda = () => {
    expect("{")
    let args = []
    let stmt = []
    if (!eat("}")) {
      stmt.push(value())
      if (match(",") || match("->")) {
        args = stmt
        stmt = []
        while (!eat("->")) {
          expect(",")
          args.push(value())
        }
      }
      while (!eat("}")) {
        stmt.push(value())
      }
    }
    return `(${args.join(",")}){${stmt.map(s => `${s};`).join("")}}`
  }

  const tokens = program.match(/->|[(){},]|[_A-Z][_A-Z0-9]*|\d+/gi)
  const match = x => tokens[0] === x
  const eat = x => match(x) && tokens.shift()
  const expect = x => {
    if (match(x)) {
      return tokens.shift()
    } else {
      throw new Error(`Expecting ${x}`)
    }
  }

  try {
    const out = func()
    expect(undefined)
    return out
  } catch (e) {
    return null
  }
}
32 minutes agoRefactorDiscuss
2 kyu
Regular Expression - Check if divisible by 0b111 (7)
JavaScript:
const solution = /^(0|(10((0|11)(1|00))*(10|(0|11)01)|11)(01*0(0|101|1(1|00)((0|11)(1|00))*(10|(0|11)01)))*1)+$/;
32 minutes agoRefactorDiscuss
2 kyu
Game of Go
JavaScript:
class Go {
  constructor(size1, size2=size1)
  {
    this.construct(size1, size2);
  }
  deepEquals(a, b)
  {
    for(var i=0; i<a.length; i++)
      for(var j=0; j<a[i].length; j++)
        if(a[i][j]!=b[i][j])
          return false;
    return true;
  }
  deepCopy(b)
  {
    var r=[];
    for(var i=0; i<b.length; i++)
    {
      r.push([]);
      for(var j=0; j<b[i].length; j++)
        r[i].push(b[i][j]);
    }
    return r;
  }
  valid(b, r, c)
  {
    return r>=0&&r<b.length&&c>=0&&c<b[0].length&&b[r][c]!='z';
  }
  piece(black)
  {
    if(black)
      return 'x';
    return 'o';
  }
  surrounded(b, r, c, cap)
  {
    if(!this.valid(b, r, c)||b[r][c]==cap)
      return true;
    if(b[r][c]=='.')
      return false;
    b[r][c]='z';
    return this.surrounded(b, r-1, c, cap)&&this.surrounded(b, r, c-1, cap)&&this.surrounded(b, r+1, c, cap)&&this.surrounded(b, r, c+1, cap);
  }
  capture(b, black)
  {
    var cap=this.piece(black);
    var temp=this.deepCopy(b);
    var c=[];
    for(var i=0; i<b.length; i++)
    {
      c.push([]);
      for(var j=0; j<b[i].length; j++)
      {
        c[i].push(temp[i][j]!=cap&&this.surrounded(temp, i, j, cap));
        temp=this.deepCopy(b);
      }
    }
    for(var i=0; i<b.length; i++)
      for(var j=0; j<b[i].length; j++)
        if(c[i][j])
          temp[i][j]='.';
    return temp;
  }
  moveOnce(m)
  {
    if(m==null||m.length<2)
      throw "Bad move length";
    var l=m.length-1, row=this.board.length-+m.substring(0, l), col=m.charCodeAt(l)-'A'.charCodeAt(0);
    if(col>7)
      col--;
    if(!this.valid(this.board, row, col)||this.board[row][col]!='.')
      throw "Tried to place in a taken spot";
    var temp=this.deepCopy(this.board); 
    temp[row][col]=this.piece(this.black);
    temp=this.capture(temp, this.black);
    var t2=this.deepCopy(temp);
    if(this.deepEquals(temp, this.boards[this.boards.length-1])||this.surrounded(t2, row, col, this.piece(!this.black)))
      throw 'Self-capture or ko';
    this.pass();
    this.board=temp;
  }
  move()
  {
    for(var i in arguments)
      this.moveOnce(arguments[i]);
  }
  handicapStones(n)
  {
    if(this.board.length!=this.board[0].length||(this.board.length!=9&&this.board.length!=13&&this.board.length!=19)||this.hasMoved||n<1||n>9)
      throw "Bad boy!";
    var min=3;
    if(this.board.length==9)
    {
      if(n>5)
        throw "Bad boy!";
      min=2;
    }
    var half=Math.floor(this.board.length/2);
    var max=this.board.length-1-min;
    this.board[min][max]='x';
    if(--n>0)
      this.board[max][min]='x';
    if(--n>0)
      this.board[max][max]='x';
    if(--n>0)
      this.board[min][min]='x';
    if(--n>0)
      this.board[half][half]='x';
    if(--n>0)
      this.board[half][min]='x';
    if(--n>0)
      this.board[half][max]='x';
    if(--n>0)
      this.board[min][half]='x';
    if(--n>0)
      this.board[max][half]='x';
    this.hasMoved=true;
  }
  construct(size1, size2)
  {
    if(size1>25||size2>25)
      throw "Daddy it's too big!";
    this.black=true;
    this.turn='black';
    this.board=[];
    this.boards=[];
    this.hasMoved=false;
    this.size={"height": size1, "width": size2};
    for(var i=0; i<size1; i++)
    {
      this.board.push([]);
      for(var j=0; j<size2; j++)
        this.board[i].push('.');
    }
    this.boards.push(this.board);
  }
  reset()
  {
    this.construct(this.board.length, this.board[0].length);
  }
  getPosition(m)
  {
    var row=this.board.length-+m.substring(0, m.length-1);
    var col=m.charCodeAt(m.length-1)-'A'.charCodeAt(0);
    if(col>7)
      col--;
    return this.board[row][col];
  }
  rollback(n)
  {
    if(n>=this.boards.length)
      throw "Too much rollback!";
    if(n%2)
    {
      this.black=!this.black;
      if(this.black)
        this.turn='black';
      else
        this.turn='white';
    }
    this.board=this.boards.splice(this.boards.length-n)[0];
  }
  pass()
  {
    this.black=!this.black;
    if(this.black)
      this.turn='black';
    else
      this.turn='white';
    this.hasMoved=true;
    this.boards.push(this.board);
  }
}
32 minutes agoRefactorDiscuss
2 kyu
Multi Line Task++: Hello World
JavaScript:
0[
c=
'\
c\
o\
n\
s\
t\
r\
u\
c\
t\
o\
r'
][
c]
`f
=\
_\
=\
>\
"\
H\
e\
l\
l\
o\
,\
 \
w\
o\
r\
l\
d\
!"
`
()
34 minutes agoRefactorDiscuss
2 kyu
Assembler interpreter (part II)
JavaScript:
function assemblerInterpreter(program) {
  return interprete(compile(parse(program)))
}

function parse(program) {
  let instructions = []
  for (const raw of program.split(/\n/)) {
    let line = raw.replace(/;.*/, "").trim()
    let match =
      RegExp(`^(msg)${"(?: +([a-z]|'[^']*'),?)?".repeat(10)}`).exec(line) ||
      /^(ret|end)/.exec(line) ||
      /^(inc|dec) +([a-z])/.exec(line) ||
      /^(mov|add|sub|mul|div) +([a-z]), +([a-z]|-?[\d]+)/.exec(line) ||
      /^(cmp) +([a-z]|-?\d+), +([a-z]|-?\d+)/.exec(line) ||
      /^(call|jmp|jn?e|j[gl]e?) +(\w+)/.exec(line) ||
      /^(\w+)(:)/.exec(line)
    if (match) {
      let instruction = match.slice(1)
      if (instruction[1] === ":") {
        instruction = ["label", instruction[0]]
      }
      instructions.push(instruction.filter(Boolean))
    }
  }
  return instructions
}

function compile(instructions) {
  let code = []
  let jumps = []
  let labels = new Map()
  let constants = new Map()
  let constant = k =>
    constants.has(k)
      ? constants.get(k)
      : constants.set(k, constants.size) && constants.size - 1
  for (let i = 0; i < instructions.length; ++i) {
    let instruction = instructions[i]
    if (instruction[0] == "label") {
      labels.set(instruction[1], code.length)
    } else if (instruction[0] === "call" || instruction[0][0] == "j") {
      jumps.push([code.length, instruction[1]])
      code.push([instruction[0], -1])
    } else {
      let op = instruction[0]
      let args = instruction.slice(1).map(operand => {
        if (/^'/.test(operand)) return 100 + constant(eval(operand))
        if (/\d/.test(operand)) return 100 + constant(parseInt(operand, 10))
        return operand.charCodeAt(0) - 97
      })
      if (op === "msg") {
        for (let arg of args) {
          code.push([op, arg])
        }
      } else {
        code.push([op, ...args])
      }
    }
  }
  for (let [from, to] of jumps) {
    code[from][1] = labels.get(to)
  }
  return [Array.from(constants.keys()), code]
}

function interprete([pool, code]) {
  const RK = a => (a >= 100 ? pool[a - 100] : registers[a])
  const registers = new Int32Array(26)
  const stack = []
  let output = ""
  let PC = 0
  let ZF = 0
  for (;;) {
    if (PC >= code.length) return -1
    let [op, a, b] = code[PC++]
    if (op === "end") break
    else if (op === "mov") registers[a] = RK(b)
    else if (op === "inc") registers[a]++
    else if (op === "dec") registers[a]--
    else if (op === "add") registers[a] += RK(b)
    else if (op === "sub") registers[a] -= RK(b)
    else if (op === "mul") registers[a] *= RK(b)
    else if (op === "div") registers[a] /= RK(b)
    else if (op === "cmp") ZF = RK(a) - RK(b)
    else if (op === "jmp") PC = a
    else if (op === "jne") ZF !== 0 && (PC = a)
    else if (op === "je") ZF === 0 && (PC = a)
    else if (op === "jle") ZF <= 0 && (PC = a)
    else if (op === "jl") ZF < 0 && (PC = a)
    else if (op === "jge") ZF >= 0 && (PC = a)
    else if (op === "jg") ZF > 0 && (PC = a)
    else if (op === "call") stack.push(PC) && (PC = a)
    else if (op === "ret") PC = stack.pop()
    else if (op === "msg") output += RK(a)
  }
  return output
}
35 minutes agoRefactorDiscuss
2 kyu
The position of a digital string in a infinite digital string
JavaScript:
function numIndex(n) {
  if(n<10) return n-1;
  var c = 0;
  for(let i=1;;i++) {
    c += i*9*Math.pow(10,i-1);
    if(n<Math.pow(10,i+1)) return c+(i+1)*(n-Math.pow(10,i));
  }
}

function findPosition(str){
  if(/^0+$/.test(str))return numIndex(+(1+str))+1;
  for(let l=1; l<=str.length; l++) {
    let poss = [];
    for(let i=0; i<l; i++) {
      let sdt = str.slice(0,l-i), end = str.slice(l-i,l);
      for(let c of (+end?[end+sdt,(end-1)+sdt]:[end+sdt])) {
        if(c[0]==='0') continue;
        let ds = c, n = +c;
        while(ds.length<str.length+l) ds += (++n);
        if(ds.indexOf(str)!==-1) poss.push(numIndex(+c)+ds.indexOf(str)); 
      }
    }
    if(poss.length) return Math.min(...poss);
  }
}
35 minutes agoRefactor
function findPosition(num) {
    var indexes = [];
    for (var step = 1; step <= num.length; step++) {
        for (var start = 0; start < step; start++) {
            var index = tryToParse(num, start, step);
            if (index >= 0) indexes.push(index);
        }
    }

    if (!indexes.length) {
        // special case, for all is zero
        return getTotalLength(parseInt('1' + num)) + 1;
    }

    return Math.min.apply(Math, indexes);
}

function tryToParse(num, start, step) {
    var n;
    if (start + step <= num.length) {
        n = parseInt(num.substr(start, step));
    } else {
        // |----num----|
        // |-p2-|--p1--|
        var p1 = num.substr(start);
        var p2 = num.substr(0, start);
        var common = p1.length + p2.length - step;

        // |---step----|
        // |-xx-|--p2--|, n - 1
        // |--p1--|-xx-|, n
        var chs = p2.substr(common).split('');
        if (chs.every((c) => c == '9')) {
            p1 = p1 + chs.map(() => '0').join('');
            n = parseInt(p1);
        } else {
            p1 = p1 + p2.substr(common);
            n = parseInt(p1);
            n++;
        }
        if (String(n - 1).substr(step - p2.length) != p2) return -1;
    }

    var tokens = [];
    var len = 0;

    if (start) {
        var prev = String(n - 1);
        tokens.push(prev.substr(prev.length - start));
        len += start;
    }

    var x = n;
    while (len < num.length) {
        var str = String(x);
        if (str.length + len > num.length) {
            tokens.push(str.substr(0, num.length - len));
            len += num.length - len;
        } else {
            tokens.push(str);
            len += str.length;
        }
        x++;
    }

    if (tokens.join('') == num) {
        var total = getTotalLength(n);
        return total - start;
    } else {
        return -1;
    }
}

function getTotalLength(n) {
    // not include n
    var total = 0;
    var len = 1;
    var x = 10;

    while (n > x) {
        total += len * (x - x / 10);
        x *= 10;
        len++;
    }

    total += len * (n - x / 10);
    return total;
}
6 days agoRefactorDiscuss
2 kyu
Break the pieces
JavaScript:
Array.prototype.mapCells = function(fn){ return this.map((row, i) => row.map((c, j) => fn(c, i, j))); }

function breakPieces (shape){
  var sh = shape.split('\n').map(row => row.split('').map(c => c == ' ' ? 0 : c));
  sh.push([]); sh.unshift([]); // to simplify boundary checks
  
  // Mark pieces on shape
  var piece = 1;
  sh.mapCells((c, i, j) => { if (!sh[i][j] && fill(i, j)) piece++; });
  
  // Done
  var result = [];
  while(--piece > 0) result.push(extract(piece));
  return result;
  
  // Fills area with number if it is inner area, '*' otherwise
  // Returns 'true' if it is inner area
  function fill(i, j){
   if (i<0 || j<0 || i>=sh.length || j>=sh[i].length || sh[i][j]=='*') return false;
   if (sh[i][j]) return true;
   sh[i][j] = piece;
   [[i-1, j],[i, j+1],[i+1, j],[i, j-1]].forEach(p => { if (!fill(...p)) sh[i][j] = '*'; });
   return sh[i][j] == piece;
  }
  
  // Extracts piece by number
  function extract(n){
    return stringify(fixCorners(sh.mapCells((c, i, j) => ('-|+'.indexOf(c) >= 0 && around(i, j)) ? c : ' ')));

    function around(i, j){
      var c = 0;
      [-1,0,1].forEach(k => [-1,0,1].forEach(l => c += Number(sh[k+i][l+j] == n)));
      return c > 0;
    }
    function fixCorners(sh){
      var replace = (i,j) => {
        var v = sh[i-1][j] == '|' || sh[i+1][j] == '|',
            h = sh[i][j-1] == '-' || sh[i][j+1] == '-';
        return v && h ? '+' : v ? '|' : '-';
      };
      return sh.mapCells((c, i, j) => c == '+' ? replace(i,j) : c);
    }
    function stringify(sh){
      var lm = Infinity;
      return sh.map   (row => row.join(''))
               .filter(row => row.trim())
               .map   (row => (row = row.trimRight(), 
                               lm = Math.min(lm, row.length-row.trim().length), 
                               row))
               .map   (row => row.substr(lm))
               .join('\n');
    }
  }
}
36 minutes agoRefactorDiscuss
2 kyu
Whitespace Interpreter
JavaScript:
function whitespace(code, input) {
  return (new Whitespace(code, input)).interpret();
}

var Whitespace = function (code, input) {
  this.code = code.replace(/[^ \t\n]/g, '').replace(/ /g, 's').replace(/\t/g, 't').replace(/\n/g, 'n');;
  this.input = input;
  this.stack = [];
  this.output = '';
  this.heap = {};
  this.labels = {};
  this.cursor = 0;
  this.subroutinestack = [];
}

Whitespace.prototype.interpret = function() {
     this.codearray = this.code.match(/ss[st]*n|sts[st]*n|stn[st]*n|sns|snt|snn|tsss|tsst|tssn|tsts|tstt|tts|ttt|tnss|tnst|tnts|tntt|nss[st]*n|nst[st]*n|nsn[st]*n|nts[st]*n|ntt[st]*n|ntn|nnn/g);
     if (this.code != this.codearray.join('')) { throw "Invalid code"; }
     if (this.codearray.indexOf('ssn') > -1 || this.codearray.indexOf('stsn') > -1 || this.codearray.indexOf('stnn') > -1) {
       throw "Invalid number format: there must be at least one bit before terminal";
     }
     for (var i = 0; i < this.codearray.length; i++) {
       if (this.codearray[i].indexOf('nss') === 0) {
         if (this.labels[this.codearray[i].slice(3)]) { throw "Non-unique label at " + i + ": " + this.codearray[i]; }
         this.labels[this.codearray[i].slice(3)] = i;
       }
     }
    this.exit = false;
    while (this.cursor < this.codearray.length && !this.exit) {
      var command = this.codearray[this.cursor];
      command = command.match(/^(ss|sts|stn|nss|nst|nsn|nts|ntt)(.*n)/) || command;
      if (typeof(command) === "object") { this[command[1]](command[2]); }
      else { this[command](); }     
      this.cursor++;
    }
    if (!this.exit) { throw "Bad exit"; }
  return this.output;
}

Whitespace.prototype.ss   = function(n) { this.stack.push(this.parseNumber(n)); }

Whitespace.prototype.sts  = function(n) {
  n = this.parseNumber(n);
  if (n < 0 || n > this.stack.length - 1) { throw "Failure to copy item at nonexisting index"; }
  var item = this.stack.length - n - 1;
  this.stack.push(this.stack[item]);
}

Whitespace.prototype.stn = function(n) {
  n = this.parseNumber(n);
  if (n < 0 || n > this.stack.length) { this.stack = [this.stack.pop()]; }
  else {
    var top = this.stack.pop();
    this.stack = this.stack.slice(0, this.stack.length - n);
    this.stack.push(top);
  }
}

Whitespace.prototype.sns = function() {
  if (!this.stack.length) { throw "Failed to run sns() with empty stack"; }
  this.stack.push(this.stack[this.stack.length - 1]);
}

Whitespace.prototype.snt = function() {
  this.stack = this.stack.concat([this.stack.pop(), this.stack.pop()]);
}

Whitespace.prototype.snn = function() {
  if (!this.stack.length) { throw "Failed to run snn() with empty stack"; }
  this.stack.pop();
}

Whitespace.prototype.tsss = function() {
  if (this.stack.length < 2) { throw "Failed to do arithmetics with less than 2 values in stack"; }
  var a = this.stack.pop(),
      b = this.stack.pop();
  this.stack.push(b + a);
}

Whitespace.prototype.tsst = function() {
  if (this.stack.length < 2) { throw "Failed to do arithmetics with less than 2 values in stack"; }
  var a = this.stack.pop(),
      b = this.stack.pop();
  this.stack.push(b - a);
}

Whitespace.prototype.tssn = function() {
  if (this.stack.length < 2) { throw "Failed to do arithmetics with less than 2 values in stack"; }
  var a = this.stack.pop(),
      b = this.stack.pop();
  this.stack.push(b * a);
}

Whitespace.prototype.tsts = function() {
  if (this.stack.length < 2) { throw "Failed to do arithmetics with less than 2 values in stack"; }
  var a = this.stack.pop(),
      b = this.stack.pop();
  if (!a) { throw "Attempt to divide by zero"; }
  this.stack.push(Math.floor(b/a));
}

Whitespace.prototype.tstt = function() {
  if (this.stack.length < 2) { throw "Failed to do arithmetics with less than 2 values in stack"; }
  var a = this.stack.pop(),
      b = this.stack.pop();
  if (!a) { throw "Attempt to modulo by zero"; }
  this.stack.push(b - Math.floor(b/a) * a);
}

Whitespace.prototype.tts = function() {
  if (this.stack.length < 2) { throw "Stack too short for tts() heap operation"; }
  var a = this.stack.pop(),
      b = this.stack.pop();
  this.heap[b] = a;
}

Whitespace.prototype.ttt = function() {
  var a = this.stack.pop();
  if (this.heap[a] === undefined) { throw "Failure to read from undefined heap address"; }
  this.stack.push(this.heap[a]);
}

Whitespace.prototype.tnss = function() {
  if(!this.stack.length) { throw "Failure to output from empty stack at tnst()";}
  this.output += String.fromCharCode(this.stack.pop());
}

Whitespace.prototype.tnst = function() {
  if(!this.stack.length) { throw "Failure to output from empty stack at tnst()";}
  this.output += this.stack.pop();
}

Whitespace.prototype.tnts = function() {
  if (!this.input.length) { throw "Failure to read character from input"; }
  else {
    var a = this.input[0];
    this.input = this.input.slice(1);
  }
  if (!this.stack.length) { throw "Failure to read heap address from empty stack at tnts()"; }
  else {
    this.heap[this.stack.pop()] = a.charCodeAt();
  }
}

Whitespace.prototype.tntt = function() {
  if (!this.input.length) { throw "Failure to read number from input"; }
  else {
    var arr = this.input.split('\n');
    var a = arr[0];
    this.input = arr.slice(1).join('\n');
  }
  if (!this.stack.length) { throw "Failure to read heap address from empty stack at tntt()"; }
  else {
    this.heap[this.stack.pop()] = parseInt(a);
  }
}

Whitespace.prototype.nss = function(l) { }

Whitespace.prototype.nst = function(l) {
  this.subroutinestack.push(this.cursor);
  this.cursor = this.labels[l];
}

Whitespace.prototype.nsn = function(l) {
  this.cursor = this.labels[l];
}

Whitespace.prototype.nts = function(l) {
  if (!this.stack.length) { throw "Failure to pop condition for jump from stack: empty stack"; }
  if (!this.stack.pop()) { this.cursor = this.labels[l]; }
}

Whitespace.prototype.ntt = function(l) {
  if (!this.stack.length) { throw "Failure to pop condition for jump from stack: empty stack"; }
  if (this.stack.pop() < 0) { this.cursor = this.labels[l]; }
}

Whitespace.prototype.ntn = function() {
  this.cursor = this.subroutinestack.pop();
}

Whitespace.prototype.nnn = function() {
  this.exit = true;
}

Whitespace.prototype.parseNumber = function(codedNumber) {
  var n = parseInt(codedNumber.slice(1, -1).replace(/s/g, '0').replace(/t/g, '1') || '0', 2)
  if (codedNumber[0] === 't') { n = -n; }
  return n;
}
36 minutes agoRefactorDiscuss
2 kyu
Insane Coloured Triangles
JavaScript:
 
function rule(a,b) {
   if ( a == b ) {
      return a;
   }
   if ( a != 'R' && b != 'R' ) {
      return 'R';
   }
   if ( a != 'G' && b != 'G' ) {
      return 'G';
   }  
   if ( a != 'B' && b != 'B' ) {
      return 'B';
   }
   return "";
}

function reduceSimple(row) {
   var retval = "";
   for ( var i = 0; i < row.length - 1; ++i ) {
      retval += rule(row[i],row[i+1]);
   }
   return retval;
}

function reduce(row) {
   var windowsize = 1; 
   while (windowsize*3 + 1 < row.length) {
      windowsize = windowsize * 3;
   }
   if ( windowsize == 1 ) {
      var retval = reduceSimple(row);
      return retval;
   }
   var retval = "";
   for ( var x = 0; x < row.length - windowsize; ++x ) {
      retval += rule(row[x],row[x+windowsize]);
   }
   return retval;
}

function triangle(row) {
   while ( row.length > 1 ) {
      row = reduce(row);
   }
   return row;
}
37 minutes agoRefactorDiscuss
2 kyu
Simpler Interactive Interpreter
Python:
"""
My solution for Simpler Interactive Interpreter kata:
https://www.codewars.com/kata/simpler-interactive-interpreter
Level: 2 kyu
"""

import re
import collections

#-------------------------------------------------------------------------------
# Lexer
#-------------------------------------------------------------------------------

class Token:
    def __init__(self, token_type, token_value):
        self.type = token_type
        self.value = token_value

class Lexer:
    def __init__(self):
        self.rules = [
            ('identifier', r'\s*[A-Za-z_][A-Za-z0-9_]*\s*'),
            ('assignment', r'\s*=\s*'),
            ('minus', r'\s*-\s*'),
            ('plus', r'\s*\+\s*'),
            ('mul', r'\s*\*\s*'),
            ('div', r'\s*\/\s*'),
            ('mod', r'\s*\%\s*'),
            ('l_paren', r'\s*\(\s*'),
            ('r_paren', r'\s*\)\s*'),
            ('number', r'\s*[0-9]*\.?[0-9]+\s*')
            ]
        parts = []
        for name, rule in self.rules:
            parts.append("(?P<{}>{})".format(name, rule))
        self.regexec = re.compile("|".join(parts))
        self.expression = None
        self.position = 0

    def set_expression(self, expression):
        self.expression = expression.strip()
        self.position = 0

    def get_next_token(self):
        if self.position >= len(self.expression):
            return Token("end of expression", None)
        match = self.regexec.match(self.expression, self.position)
        if not match:
            # something is wrong with the input string
            raise Exception('ERROR: Invalid input.')
        self.position = match.end()
        token_type = match.lastgroup
        value = match.group(match.lastgroup).strip()
        value = value if token_type != 'number' else self.handle_number(value)
        return Token(token_type, value)

    def handle_number(self, value):
        try:
            value = int(value)
        except ValueError:
            value = float(value)
        return value

    def peek(self):
        if self.position >= len(self.expression):
            return Token("end of expression", None)
        match = self.regexec.match(self.expression, self.position)
        token_type = match.lastgroup
        value = match.group(match.lastgroup).strip()
        return Token(token_type, value)

#-------------------------------------------------------------------------------
# Parser
#-------------------------------------------------------------------------------

class AST():
    pass

class BinOp(AST):
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right

class Num(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value

class UnaryOp(AST):
    def __init__(self, op, expr):
        self.token = self.op = op
        self.right = expr

class Identifier(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value

class VarName(AST):
    def __init__(self, token):
        self.token = token
        self.value = token.value

class Assign(AST):
    def __init__(self, left, op, right):
        self.left = left
        self.token = self.op = op
        self.right = right

class Parser():
    """
    Implements EBNF:
    expression     ::= assignment | additive
    assignment     ::= var-name '=' additive
    additive       ::= multiplicative ((PLUS | MINUS) multiplicative)*
    multiplicative ::= factor ((MUL | DIV | MOD) factor)*
    factor         ::= (PLUS | MINUS) factor | NUMBER |
                       assignment | IDENTIFIER |
                       L_PAREN additive R_PAREN
    var-name       ::= IDENTIFIER
    """

    def __init__(self, lexer):
        self.lexer = lexer
        self.current_token = None

    def error(self):
        raise Exception('invalid syntax')

    def eat(self, token_type):
        if self.current_token.type == token_type:
            self.current_token = self.lexer.get_next_token()
        else:
            self.error()

    def set_expression(self, expression):
        self.lexer.set_expression(expression)
        self.current_token = self.lexer.get_next_token()

    def parse(self):
        node = self.expression()
        if self.current_token.type != 'end of expression':
            # some other stuff is in the input string
            raise Exception('ERROR: Invalid input.')
        return node

    def expression(self):
        """
        expression ::= assignment | additive
        """
        current_token = self.current_token
        next_token = self.lexer.peek()
        if current_token.type == 'identifier' and \
        next_token.type == 'assignment':
            return self.assignment()
        elif current_token.type in ('number', 'identifier', 'l_paren'):
            return self.additive()

    def additive(self):
        """
        additive ::= multiplicative ((PLUS | MINUS) multiplicative)*
        """
        node = self.multiplicative()
        while self.current_token.type in ('plus', 'minus'):
            token = self.current_token
            if token.type == 'plus':
                self.eat('plus')
            elif token.type == 'minus':
                self.eat('minus')
            node = BinOp(left=node, op=token, right=self.multiplicative())
        return node

    def multiplicative(self):
        """
        multiplicative ::= factor ((MUL | DIV | MOD) factor)*
        """
        node = self.factor()
        while self.current_token.type in ('mul', 'div', 'mod'):
            token = self.current_token
            if token.type == 'mul':
                self.eat('mul')
            elif token.type == 'div':
                self.eat('div')
            elif token.type == 'mod':
                self.eat('mod')
            node = BinOp(left=node, op=token, right=self.factor())
        return node

    def factor(self):
        """
        factor ::= (PLUS | MINUS) factor | NUMBER |
                   assignment | IDENTIFIER |
                   L_PAREN additive R_PAREN
        """
        current_token = self.current_token
        next_token = self.lexer.peek()
        if current_token.type == 'plus':
            self.eat('plus')
            node = UnaryOp(op=current_token, expr=self.factor())
        elif current_token.type == 'minus':
            self.eat('minus')
            node = UnaryOp(op=current_token, expr=self.factor())
        elif current_token.type == 'number':
            self.eat('number')
            node = Num(current_token)
        elif current_token.type == 'identifier' and next_token.type == 'assignment':
            return self.assignment()
        elif current_token.type == 'identifier':
            return self.identifier()
        elif current_token.type == 'l_paren':
            self.eat('l_paren')
            node = self.additive()
            self.eat('r_paren')
        return node

    def assignment(self):
        """
        assignment ::= var-name '=' additive
        """
        node = Identifier(self.current_token)
        self.eat('identifier')
        op = self.current_token
        self.eat('assignment')
        node = Assign(left=node, op=op, right=self.additive())
        return node

    def identifier(self):
        """
        IDENTIFIER
        """
        node = VarName(self.current_token)
        self.eat('identifier')
        return node

#-------------------------------------------------------------------------------
# abstract syntax tree walker
#-------------------------------------------------------------------------------

class NodeVisitor():
    def visit(self, node):
        method_name = 'visit_' + type(node).__name__
        visitor = getattr(self, method_name, self.generic_visit)
        return visitor(node)

    def generic_visit(self, node):
        raise Exception('No visit_{} method'.format(type(node).__name__))

    def visit_NoneType(self, _):
        return ''

#-------------------------------------------------------------------------------
# Variable Table, Semantic Analyser
#-------------------------------------------------------------------------------

class Variable():
    def __init__(self, name, value):
        self.name = name
        self.value = value

class ScopedVarTable():
    def __init__(self):
        self.vars = collections.OrderedDict()

    def insert(self, var):
        self.vars[var.name] = var

    def lookup(self, var_name):
        var = self.vars.get(var_name)
        if not self.vars or not var_name in self.vars.keys():
            # No variables defined.
            raise Exception('ERROR: Invalid identifier. No variable with '
                            'name \'{}\' was found.'.format(var_name))
        return var

    def exists(self, var_name):
        return var_name in self.vars.keys()

class SemanticAnalyser(NodeVisitor):
    def __init__(self):
        self.var_table = ScopedVarTable()
        self.current_scope = self.var_table
        self.functions = {}

    def visit_BinOp(self, node):
        self.visit(node.left)
        self.visit(node.right)

    def visit_Num(self, node):
        pass

    def visit_UnaryOp(self, node):
        self.visit(node.right)

    def visit_VarName(self, node):
        self.current_scope.lookup(node.value)

    def visit_Assign(self, node):
        var_name = node.left.value
        if var_name in self.functions.keys():
            raise Exception('ERROR: Variable name \'{}\' already defined as '
                            'function name.'.format(var_name))
        var_value = self.visit(node.right)
        var = Variable(name=var_name, value=var_value)
        self.current_scope.insert(var)

#-------------------------------------------------------------------------------
# Interpreter
#-------------------------------------------------------------------------------

class Interpreter(NodeVisitor):
    def __init__(self):
        self.var_table = ScopedVarTable()
        self.current_scope = self.var_table
        self.functions = {}
        self.lexer = Lexer()
        self.parser = Parser(self.lexer)
        self.semantic_analyser = SemanticAnalyser()

    def input(self, expression):
        self.parser.set_expression(expression)
        tree = self.parser.parse()
        self.semantic_analyser.visit(tree)
        result = self.visit(tree)
        return result

    def visit_BinOp(self, node):
        if node.op.type == 'plus':
            return self.visit(node.left) + self.visit(node.right)
        elif node.op.type == 'minus':
            return self.visit(node.left) - self.visit(node.right)
        elif node.op.type == 'mul':
            return self.visit(node.left) * self.visit(node.right)
        elif node.op.type == 'div':
            return self.visit(node.left) / self.visit(node.right)
        elif node.op.type == 'mod':
            return self.visit(node.left) % self.visit(node.right)

    def visit_Num(self, node):
        return node.value

    def visit_UnaryOp(self, node):
        if node.op.type == 'plus':
            return +self.visit(node.right)
        elif node.op.type == 'minus':
            return -self.visit(node.right)

    def visit_VarName(self, node):
        var = self.current_scope.lookup(node.value)
        return var.value

    def visit_Assign(self, node):
        var = Variable(name=node.left.value, value=self.visit(node.right))
        self.current_scope.insert(var)
        return var.value
        
6 days agoRefactorDiscuss
JavaScript:
Array.prototype.last = function() {
    return this[this.length-1];
}
 
function Interpreter()
{
    this.vars = {};
    this.functions = {};
}
 
Interpreter.prototype.tokenize = function (program)
{
    if (program === "")
        return [];
 
    var regex = /\s*([-+*\/\%=\(\)]|[A-Za-z_][A-Za-z0-9_]*|[0-9]*\.?[0-9]+)\s*/g;
    return program.split(regex).filter(function (s) { return !s.match(/^\s*$/); });
};
 
Interpreter.prototype.input = function (expr)
{
 
    var _this = this;
    var tokens = this.tokenize(expr);
    var ops = [];
    var stack = [];
 
    tokens.forEach(function(token) {
 
      if(_this.isOperator(token)) {
        if(_this.getOperatorRank(ops.last()) < _this.getOperatorRank(token) || (stack.length >= 2 && stack[stack.length-2] == '(' ) ) {
          ops.push(token);
        } else {
          var b = stack.pop();
          var a = stack.pop();
          stack.push(_this.doOp(a, ops.pop(), b));
          ops.push(token);
        }
      }else if(token == "(") {
        stack.push(token);
      } else if(_this.isNumber(token)) {
        stack.push(token);
      } else if(_this.isIdentifier(token)) {
        stack.push(token);
      } else if(token == ")") {
        while(stack.length > 0){
          var b = stack.pop();
          var a = stack.pop();
          if(stack.last() == "(") {
            stack.pop();
            stack.push(_this.doOp(a, ops.pop(), b));
            break;
          }
        };
       
      }
    });
   
    while(stack.length > 1) {
      var b = stack.pop();
      var a = stack.pop();
      stack.push(_this.doOp(a, ops.pop(), b));
    }
    return (tokens.length > 0)?_this.getVal(stack.pop()):"";
};
 
Interpreter.prototype.isDigit = function(token) {
  return (token.length == 1 && token >= "0" && token <= "9");
};
 
Interpreter.prototype.isLetter = function(token) {
  return token.length == 1 && (token >= "a" && token <= "z" || token >="A" && token <= "Z");
}
 
Interpreter.prototype.isOperator = function(token) {
  return ["+", "-", "*", "/", "%", "="].indexOf(token) >= 0;
}
 
Interpreter.prototype.getOperatorRank = function(token) {
  switch(token) {
    case "=": return 0;
    case "+":
    case "-": return 1;
    case "*":
    case "/":
    case "%": return 2;
  }
  return -1;
}
 
Interpreter.prototype.isIdentifier = function(token) {
  var regex = /^[a-zA-Z]([a-zA-Z_0-9]*)?$/g;
  return regex.test(token);
}
 
Interpreter.prototype.isNumber = function(token) {
  var regex = /^[\+\-]?\d*[\.]?\d+$/g;
  return regex.test(token);
}
Interpreter.prototype.getVal = function(a) {
  if(this.isNumber(a)) {
    a = Number(a);
  } else if(this.isIdentifier(a)) {
    var aa = this.vars[a];
    if(typeof aa === "undefined") {
      throw "No variable with name '" + a + "' was found.";
    }
    a = aa;
  }
  return a;
}
Interpreter.prototype.doOp = function(a, op, b) {
  if(op != "=") {
    var aa = this.getVal(a);
    var bb = this.getVal(b);
   
    switch(op) {
      case "+": return aa + bb;
      case "-": return aa - bb;
      case "*": return aa * bb;
      case "/": return aa / bb;
      case "%": return aa % bb;
      case "=": this.vars[a] = bb; return a;
    }
  } else {
    this.vars[a] = this.getVal(b);
    return a;
  }
}
38 minutes agoRefactorDiscuss
2 kyu
Decode the Morse code, for real
JavaScript:
function classify(items, centroids) {
  var clusters = [];
  for (let i = 0; i < centroids.length; i++) {
    clusters.push([]);
  }
 
  items.forEach(item => {
    var distances = [];
    var cluster_index = 0;
   
    for (let i = 0; i < centroids.length; i++) {
      distances.push(Math.sqrt(Math.pow(item.length - centroids[i], 2)));
      //distances.push(Math.abs(item.length - centroids[i]));
    }
 
    for (let i = 0, min = Math.min(...distances); i < distances.length; i++) {
      if (distances[i] === min) {
         if (i === 2 && item[0] === '1')
          cluster_index = 1;
         else
          cluster_index = i;
        break;
      };
    }
 
    clusters[cluster_index].push(item);
  });
 
  return clusters;
}
 
function mean(items) {
  if (!items.length) return 0;
  return items.reduce((sum, item) => sum + item.length, 0) / items.length;
}
 
function kmeans(data, centroids, iterations = Infinity) {
  var clusters = null, moved = false;
 
  do {
    clusters = classify(data, centroids);
    for (let i = 0, m; i < clusters.length; i++) {
      m = mean(clusters[i]);
      if (centroids[i] !== m) {
        centroids[i] = m;
        moved = true;
        continue;
      }
      moved = false;
    }
  }
  while (iterations-- && moved)
 
  return { clusters: clusters, centroids: centroids }
}
 
function decodeBitsAdvanced(bits){
    var map = {};
    var bits = bits.replace(/^0+|0+$/g, '').match(/1+|0+/g);
    if (!bits) return '';
   
    var result = kmeans(bits, [1,3,7], 100);
    var clusters = result.clusters;
    var averages = [
      (Math.max(...clusters[0].map(item => item.length)) + Math.min(...clusters[0].map(item => item.length))) / 2,
      (Math.max(...clusters[1].map(item => item.length)) + Math.min(...clusters[1].map(item => item.length))) / 2,
      (Math.max(...clusters[2].map(item => item.length)) + Math.min(...clusters[2].map(item => item.length))) / 2,
    ]
 
    var centroids = [
      (averages[0] + averages[1]) / 2 || averages[0] || averages[1],
      (averages[1] + averages[2]) / 2 || averages[1] || averages[0] * 3,
    ]
 
    bits.reduce((map, signal) => {
      signal = signal.length;
 
      if (signal <= centroids[0]) {
        map['1'.repeat(signal)] = '.';
        map['0'.repeat(signal)] = '';
      }
 
      else if (signal <= centroids[1]) {
        map['1'.repeat(signal)] = '-';
        map['0'.repeat(signal)] = ' ';
      }
 
      else if (signal > centroids[1]) {
        map['1'.repeat(signal)] = '-';
        map['0'.repeat(signal)] = '   ';
      }
 
      return map;
    }, map)
 
    console.log(centroids, result.centroids);
   
    return bits.map(signal => {
      return map[signal];
    }).join('');
}
 
function decodeMorse(morseCode){
    if (!morseCode.length) return '';
    return morseCode.split('   ').map(word => {
      return word.trim().split(' ').map(code => {
        return MORSE_CODE[code] || code
      }).join('');
    }).join(' ');
}
38 minutes agoRefactor
var divideIntoGroups = function(items, centers) {
    var maps = centers.map((c) => {
        return {}; // length -> count
    });
    var sum = items.reduce((result, item) => {
        var n = item.size;
        var index = centers.findIndex((c, i) => i == centers.length - 1 || n <= (centers[i] + centers[i + 1]) / 2);
        // no 1s whose length is 7
        if (index == 2 && item.ch == '1') {
            index = 1;
        }
        var delta = Math.abs(n - centers[index]);
        maps[index][n] = maps[index][n] ? maps[index][n] + 1 : 1;
        return result + delta * delta;
    }, 0);
    return {maps: maps, sum: sum};
};
var getNewCenter = function(map) {
    var sum = 0, count = 0;
    for (var s in map) {
        var c = map[s];
        sum += s * c;
        count += c;
    }
    return count ? sum / count : 0;
};

var kmeans = function(items, centers) {
    var oldState = divideIntoGroups(items, centers);

    var limit = 100;
    while (limit--) {
        centers = oldState.maps.map(getNewCenter);

        var newState = divideIntoGroups(items, centers);
        if (Math.abs(oldState.sum - newState.sum) < 0.01) break;
        oldState = newState;
    }
    return newState.maps;
};

var decodeBitsAdvanced = function(bits){
    // trim 0s
    bits = bits.replace(/^0+/, '').replace(/0+$/, '');
    if (!bits) return '';

    // count 0s and 1s
    var items = bits.match(/([01])\1*/g).map((match) => {
        return {
            ch: match[0],
            size: match.length
        };
    });

    // k-means
    var centers = [1, 3, 7];
    var sizeMaps = kmeans(items, centers);

    // real centers should in the middle
    var avgs = sizeMaps.map((m) => {
        var keys = Object.keys(m).map((s) => parseInt(s));
        return (Math.min.apply(Math, keys) + Math.max.apply(Math, keys)) / 2;
    });
    var valid = avgs.filter((val) => val).length;

    // 2 limits to separate into 3 groups
    var limit1, limit2;
    if (valid == 3) {
        limit1 = (avgs[0] + avgs[1]) / 2;
        limit2 = (avgs[1] + avgs[2]) / 2;
    } else if (valid == 2) {
        var min = avgs[0] || avgs[1];
        var max = avgs[2] || avgs[1];
        if (max >= min * (3 + 7) / 2) {
            // 1 and 7
            var avg3 = (min + max) * 3 / (1 + 7);
            limit1 = (min + avg3) / 2;
            limit2 = (avg3 + max) / 2;
        } else if (max >= min * (1 + 3) / 2) {
            // 1 and 3
            limit1 = (min + max) / 2;
            limit2 = max;
        } else {
            // 3 and 7
            limit1 = min;
            limit2 = (min + max) / 2;
        }
    } else if (valid == 1) {
        limit1 = avgs[0] || avgs[1] || avgs[2];
    }

    return bits.replace(/0+|1+/g, (match) => {
        if (match[0] == '1') {
            return match.length <= limit1 ? '.' : '-';
        } else {
            if (match.length <= limit1) return '';
            if (match.length <= limit2) return ' ';
            return '   ';
        }
    });
};

var decodeMorse = function(morseCode){
    // Copy from previous kata
    return morseCode.trim().split('   ').map((codes) => {
        return codes.split(' ').map((c) => MORSE_CODE[c]).join('');
    }).join(' ');
};
6 days agoRefactorDiscuss
2 kyu
Evaluate mathematical expression
JavaScript:
function calc(expr) {

    var expressionToParse = expr.replace(/\s+/g, '').split('');
    
    function peek() {
        return expressionToParse[0] || '';
    }
    
    function get() {
        return expressionToParse.shift();
    }
    
    function number() {
        var result = get();
        while (peek() >= '0' && peek() <= '9' || peek() == '.') {
            result += get();
        }
        return parseFloat(result);
    }
    
    function factor() {
        if (peek() >= '0' && peek() <= '9') {
            return number();
        } else if (peek() == '(') {
            get(); // '('
            var result = expression();
            get(); // ')'
            return result;
        } else if (peek() == '-') {
            get();
            return -factor();
        }
        return 0; // error
    }
    
    function term() {
        var result = factor();
        while (peek() == '*' || peek() == '/') {
            if (get() == '*') {
                result *= factor();
            } else {
                result /= factor();
            }
        }
        return result;
    }
    
    function expression() {
        var result = term();
        while (peek() == '+' || peek() == '-') {
            if (get() == '+') {
                result += term();
            } else {
                result -= term();
            }
        }
        return result;
    }

    return expression();
}
39 minutes agoRefactor
const e1 = input => r1(e2(input));

const r1 = ({s: input, v: a}) => {
  if (input.length > 0 && input[0] == '+' || input[0] == '-') {
    const {s, v} = e2(input.substr(1));
	  return r1({s, v: input[0] == '+' && a + v || a - v});
  }
  return {s: input, v: a};
};

const e2 = input => r2(e3(input));

const r2 = ({s: input, v: a}) => {
  if (input.length > 0 && input[0] == '*' || input[0] == '/') {
  	const {s, v} = e3(input.substr(1));
	  return r2({s, v: input[0] == '*' && a * v || a / v});
  }
  return {s: input, v: a};
};

const e3 = input => {
  if (input[0] == '-') {
    const {s, v} = e4(input.substr(1));
    return {s, v: -v};
  }
  return e4(input);
};

const e4 = input => {
  if (input[0] == '(') {
  	const {s, v} = e1(input.substr(1));
	  if (s[0] == ')') {
	    return {s: s.substr(1), v};
  	}
	  throw "Unexpected token: Expected ), found " + s[0];
  }
  if (is_digit(input[0])) {
  	return number(input);
  }
  throw "Invalid token for e4: " + input[0];
};

const is_digit = c => c >= '0' && c <= '9';

const number = input => {
  let li = 0;
  let vi = 0;
  let lf = 0;
  let vf = 0;
  while (is_digit(input[li])) {
  	vi = vi * 10 + (input[li] - '0');
	  li += 1;
  }
  if (input[li] == '.') {
    lf = 1;
    let m = .1;
    while (is_digit(input[li + lf])) {
      vf += m * (input[li + lf] - '0');
      m *= .1;
      lf += 1;
    } 
  }
  return {s: input.substr(li + lf), v: vi + vf};
}

const calc = e => e1(e.replace(/ /g, '')).v;
6 days agoRefactorDiscuss
2 kyu
Challenge Fun #10: Integer Square Root
JavaScript:
function integerSquareRoot(s) {
  let mul = (a, b) => {
    let result = a.split``.map(d => d * b);
    for (let i = result.length - 1; i > 0; i--) {
      result[i - 1] += ~~(result[i] / 10);
      result[i] %= 10;
    }
    result = result.join``.replace(/^0+/, '');
    return result.length ? result : '0';
  }, sub = (a, b) => {
    a = '0'.repeat(Math.max(0, b.length - a.length)) + a;
    b = '0'.repeat(Math.max(0, a.length - b.length)) + b;
    let result = a.split``.map((d, i) => d - b[i]);
    for (let i = result.length - 1; i > 0; i--) if (result[i] < 0) {
      result[i] += 10;
      result[i - 1]--;
    }
    result = result.join``.replace(/^0+/, '');
    return result.length ? result : '0';
  }, lte = (a, b) => {
    a = '0'.repeat(Math.max(0, b.length - a.length)) + a;
    b = '0'.repeat(Math.max(0, a.length - b.length)) + b;
    if (a === b) return true;
    for (let i = 0; i < a.length; i++) {
      if (a[i] < b[i]) return true;
      else if (a[i] > b[i]) return false;
    }
  };
  if (s.length % 2) s = '0' + s;
  let result = '0', carry = '0';
  for (let i = 0; i < s.length; i += 2) {
    carry += s[i] + s[i + 1];
    let doubleCurrent = mul(result, '2'), j = 0;
    while (lte(mul(doubleCurrent + j, '' + j), carry) && j < 10) j++;
    result += --j;
    carry = sub(carry, mul(doubleCurrent + j, '' + j));
  }
  result = result.replace(/^0+/, '');
  return result.length ? result : '0';
}
2 hours agoRefactorDiscuss
2 kyu
DNE equivalent to PEM? Prove It!
Haskell:

{-# LANGUAGE RankNTypes #-}

module Kata where

import Prelude hiding (undefined, error)

import KataPreloaded

{- Preloaded code :
type AxiomPEM = forall a. forall b. (a -> b) -> ((a -> Void) -> b) -> b
type AxiomDNE = forall a. ((a -> Void) -> Void) -> a
-}

from :: AxiomDNE -> AxiomPEM
from dne = \ab avb -> dne $ \bv -> bv (avb $ bv . ab)

to :: AxiomPEM -> AxiomDNE
to pem = \avv -> pem id $ absurd . avv
2 hours agoRefactorDiscuss
2 kyu
C Puzzle: Pointer Monster
C:

#include <stdio.h>

char a[4][7] = {"Common", "Point", "Boost", "Better"};
char* b[4] = {a+3, a+1, a, a+2};


char* (*(c)())[4] {
    return &b;
}

char* (*(d)())[1] {
    return c()[1] - 3;
}

char buf[256];
char *pointer_monster(char * (*(*f)())[1])
{
    int len;

    len  = sprintf(buf, "%s", *f()[0]);
    len += sprintf(buf + len, "%s ", *((**f)()-1)[0] + 4);
    len += sprintf(buf + len, "%s", (*f())[0] - 4);
    len += sprintf(buf + len, "%s", f()[0][2] + 3);
    len += sprintf(buf + len, "%s", *((**f)()-1)[0] + 4);
    return buf;
}
2 hours agoRefactorDiscuss
1 kyu
7×7 Skyscrapers
C++:

#include <algorithm>
#include <array>
#include <bitset>
#include <cassert>
#include <iomanip>
#include <iostream>
#include <map>
#include <numeric>
#include <set>
#include <vector>

static constexpr bool s_debug = false;
static constexpr bool s_print_challenge = false;
static constexpr bool s_emit_code = false;

using height = unsigned;

static size_t constexpr N = 7;
enum : height { none, h1, h2, h3, h4, h5, h6, h7 };
using clue = unsigned;
using seq  = std::array<height, N>;

using option   = std::bitset<N>;
using option_seq = std::array<option, N>;

namespace utility {
  size_t forward(size_t i) { return i; }
  size_t reverse(size_t i) { return N-1-i; }

  unsigned long hint_to_mask(height h) { return h? 1ul << (h - 1) : 0; }

  static clue calc_clue(seq s) {
    height cur = none;
    clue result = none;
    auto b = s.begin(), e = s.end();
    while (b!=e) {
      result += (*b > cur);
      cur = std::max(cur, *b);
      ++b;
    }
    return result;
  }

  static clue calc_clue(option_seq s) {
    unsigned long cur = none;
    clue result = none;
    auto b = s.begin(), e = s.end();
    while (b!=e) {
      result += (b->to_ulong() > cur);
      cur = std::max(cur, b->to_ulong());
      ++b;
    }
    return result;
  }

  using SolutionSpace = std::multimap<clue, seq>;
#if 1 || defined(GENERATE_SOLUTION_SPACE)
  static SolutionSpace const solutionspace = []{
      SolutionSpace r;
      seq s;
      std::iota(begin(s), end(s), height(h1));
      
      do r.emplace(calc_clue(s), s);
      while (std::next_permutation(s.begin(), s.end()));
      if (s_emit_code) {
        std::cout << "    static SolutionSpace const solutionspace\n";
        std::cout << "    {\n";
        for (auto& c : r) {
          std::cout
            << "    { {" << c.first << "u}, "
            << "{{" 
            << c.second[0] << "u," << c.second[1] << "u," << c.second[2] << "u," 
            << c.second[3] << "u," << c.second[4] << "u," << c.second[5] << "u," 
            << c.second[6] << "u}} }," << std::endl;
        }
        std::cout << "    };\n";
      }

      return r;
  }();

  auto const hint_options = []{
    std::array<option_seq, N+1> result;

    for (auto& all : result.at(0))
      all.flip();

    for (size_t i = 1; i<N+1; ++i) {
      auto range = solutionspace.equal_range(i);
      result[i] = std::accumulate(range.first, range.second, option_seq{}, 
        [](option_seq accum, auto const&s) {
          for(auto i=0u; i<N; ++i) accum[i] |= hint_to_mask(s.second[i]);
          return accum;
        });
    }

    if (s_emit_code) {
      std::cout << "    std::array<option_seq, N+1> const hint_options = {{\n";
      for (size_t i = 0; i<N+1; ++i) {
        std::cout << "    /*" << i << "*/ {{";
        for (auto& x : result.at(i))
          std::cout << "option{\"" << x << "\"}, ";

        std::cout << "}}, \n";
      }
      std::cout << "    }};\n";
    }

    return result;
  }();
#else
    std::array<option_seq, N+1> const hint_options = {{
      /*0*/ {{option{"1111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, }}, 
      /*1*/ {{option{"1000000"}, option{"0111111"}, option{"0111111"}, option{"0111111"}, option{"0111111"}, option{"0111111"}, option{"0111111"}, }}, 
      /*2*/ {{option{"0111111"}, option{"1011111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, }}, 
      /*3*/ {{option{"0011111"}, option{"0111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, }}, 
      /*4*/ {{option{"0001111"}, option{"0011111"}, option{"0111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, }}, 
      /*5*/ {{option{"0000111"}, option{"0001111"}, option{"0011111"}, option{"0111111"}, option{"1111111"}, option{"1111111"}, option{"1111111"}, }}, 
      /*6*/ {{option{"0000011"}, option{"0000111"}, option{"0001111"}, option{"0011111"}, option{"0111111"}, option{"1111111"}, option{"1111111"}, }}, 
      /*7*/ {{option{"0000001"}, option{"0000010"}, option{"0000100"}, option{"0001000"}, option{"0010000"}, option{"0100000"}, option{"1000000"}, }}, 
    }};
#endif

  struct puzzle {
    std::array<option_seq, N> field{{{{0}}}};
    struct clues { int forward, backward; };
    std::array<clues, N> colclues, rowclues;

    template <typename Clues>
    puzzle(Clues const& input) 
      : colclues {{
        clues {input[0], input[3*N-1]},
        clues {input[1], input[3*N-2]},
        clues {input[2], input[3*N-3]},
        clues {input[3], input[3*N-4]}, 
        clues {input[4], input[3*N-5]}, 
        clues {input[5], input[3*N-6]}, 
        clues {input[6], input[3*N-7]}, 
        }},
        rowclues {{
        clues {input[4*N-1], input[N+0]},
        clues {input[4*N-2], input[N+1]},
        clues {input[4*N-3], input[N+2]},
        clues {input[4*N-4], input[N+3]},
        clues {input[4*N-5], input[N+4]},
        clues {input[4*N-6], input[N+5]},
        clues {input[4*N-7], input[N+6]},
        }}
    { 
      for (auto& r : field) for (auto& c : r) c.flip(); // start with all options
      if (s_debug) { std::cout << "-- INITIALIZED\n"; dump(); }
    }

    void preapply_hints() {
      enum { phase1, phase2, phase3, phase4 };
      for (int x : {phase1,phase2,phase3,phase4}) {
        for (size_t ri = 0; ri<N; ++ri) for (size_t ci = 0; ci<N; ++ci) {
          assert(&row(ri).at(ci) == &col(ci).at(ri));

          {
            auto& cell = row(ri).at(ci);
            if (x==phase1) cell &= hint_options.at(rowclues.at(ri).forward).at(ci);
            if (x==phase3) cell &= hint_options.at(colclues.at(ci).forward).at(ri);
          }

          {
            auto& cell = row(ri).at(reverse(ci));
            if (x==phase2) cell &= hint_options.at(rowclues.at(ri).backward).at(ci);
          }
          {
            option& cell = col(ci).at(reverse(ri));
            if (x==phase4) cell &= hint_options.at(colclues.at(ci).backward).at(ri);
          }
        }

        char const* names[] = {"row (L)", "row (R)", "col (T)", "col (B)" };
        if (s_debug) { std::cout << "-- APPLIED HINTS PHASE " << names[x] << "\n"; dump(); }
      }
      if (s_debug) { std::cout << "-- APPLY HINTS\n"; dump(); }
    }

    bool solve_exclusive_options() {
      auto isolate = [](auto&& group) {
                // count options
                int counts[N] = {0};

                {
                    option test(1);
                    for (unsigned i = 0; i < N; ++i, test<<=1) {
                        counts[i] = std::count_if(group.begin(), group.end(), [&test](option& c) { return (c & test).to_ulong(); });
                    }
                }

                // build mask of singletons
                option singletons;
                {
                    option test(1);
                    for (unsigned i = 0; i < N; ++i, test<<=1)
                        if (counts[i] == 1)
                            singletons |= test;
                }

        bool effect = false;
                option non_singletons = ~singletons;
                for (auto& c : group) {
                    if ((c & singletons).any() && (c & non_singletons).any()) {
                        effect = true;
                        c &= singletons;
                    }
                }

        return effect;
      };

      for (bool effect = true; effect;) {
        effect = false;
        for (size_t ri = 0; ri<N; ++ri) {
          if ((effect |= isolate(row(ri))) && s_debug) {
            std::cout << "EXC at row " << ri << " effect:\n";
            dump();
          }
        }
        for (size_t ci = 0; ci<N; ++ci) {
          if ((effect |= isolate(col(ci))) && s_debug) {
            std::cout << "EXC at col " << ci << " effect:\n";
            dump();
          }
        }
            }

      return false;
    }

    bool solve_isolated_groups() {
      auto isolate = [](auto& cell, auto&& group) {
        bool effect = false;
        if (std::count(group.begin(), group.end(), cell) + 0ul == cell.count()) {
          for (auto& other : group) {
            if (other != cell) {
              if ((other & cell).count()) {
                if (s_debug) {
                  if (!effect)
                    std::cout << " - exclusive group of " << cell.count() << " times " << cell << "\n";
                  std::cout << "   -> affecting other cell from " << other << " to " << (other & ~cell) << "\n";
                }
                effect = true;
                other &= ~cell;
              }
            }
          }
        }
        return effect;
      };

      for (bool effect = true; effect;) {
        effect = false;
        for (size_t ri = 0; ri<N; ++ri) {
          auto& all = row(ri);
          bool local_effect = false;
          if (s_debug) std::cout << "At row " << ri << "\n";
          for (auto& c : all) local_effect |= isolate(c, all);

          if (s_debug && local_effect) {
            std::cout << "At row " << ri << " effect:\n";
            dump();
          }

          effect |= local_effect;
        }
        for (size_t ci = 0; ci<N; ++ci) {
          auto all = col(ci);
          bool local_effect = false;
          if (s_debug) std::cout << "At col " << ci << "\n";
          for (auto& c : all) local_effect |= isolate(c, all);

          if (s_debug && local_effect) {
            std::cout << "At col " << ci << " effect:\n";
            dump();
          }

          effect |= local_effect;
        }
        if (s_debug && effect) { std::cout << "REDUCTION RUN\n"; dump(); }
        return effect;
      }
      return false;
    }

    bool eliminate_hinted_skylines() {
      auto eliminate = [=](auto& clues, auto&& actual, std::string caption) {
        auto _elim = [](clue hint, auto&& actual, auto index_order, std::string caption) {
          if (!hint) return false;
          bool effect = false;

          auto range = solutionspace.equal_range(hint);
          if (s_debug) std::cout << caption << ": solutionspace is " << solutionspace.size() << " entries, hinted " << hint << ": " << std::distance(range.first, range.second) << "\n";

          std::set<seq const*> viable;
          for (; range.first!=range.second; ++range.first) {
            auto& candidate = range.first->second;
            //auto htm = [](height h) { return option{hint_to_mask(h)}; };
            //std::cout
              //<< " *** next candidate "
              //<< "{" << htm(candidate[0]) << "," << htm(candidate[1]) << "," << htm(candidate[2]) << "," << htm(candidate[3]) << "}\n";
            bool isviable = true;

            for(auto i=0u; i<N && isviable; ++i)
            {
              auto& actual_cell = actual[index_order(i)];
              //std::cout << "Matching index " << i << " actual_cell " << actual_cell << " against candidate " << option{hint_to_mask(candidate[i])} << "\n";
              //std::cout << "Matching index " << i << " actual_cell " << actual_cell.to_ulong() << " against candidate " << hint_to_mask(candidate[i]) << "\n";
              isviable &= !!(actual_cell.to_ulong() & hint_to_mask(candidate[i])); 
            }

            //std::cout << (isviable?"VIABLE":"NOT VIABLE") << "\n";

            if (isviable)
              viable.insert(&candidate);
          }

          if (viable.empty())
            return effect; // TODO THROW

          if (s_debug) std::cout << caption << ": There are " << viable.size() << " viable matches (for clue " << hint << ") in solutionspace\n";

          auto room = std::accumulate(begin(viable), end(viable), option_seq{}, 
              [](option_seq accum, seq const*s) {
                for(auto i=0u; i<N; ++i) accum[i] |= hint_to_mask((*s)[i]);
                return accum;
              });

          if (s_debug) std::cout << caption << ": Combined room remaining: " 
            << room[0] << ", " << room[1] << ", " << room[2] << ", " << room[3] << ", " << room[4] << ", " << room[5] << ", " << room[6] << "\n";

          for(auto i=0u; i<N; ++i) {
            auto& cell = actual[index_order(i)];
            auto newval = cell & room[i];
            if (newval != cell) {
              effect = true;
              cell = newval;
            }
          }

          return effect;
        };

        bool effect = false;
        effect |= _elim(clues.forward, actual, forward, caption + " (FWD)");
        //std::cout << "FORWARD ELIMINATED\n"; dump();
        effect |= _elim(clues.backward, actual, reverse, caption + " (BCK)");
        //std::cout << "BACKWARD ELIMINATED\n"; dump();
        return effect;
      };

      bool effect = false;
      for (size_t ri = 0; ri<N; ++ri) {
        if (eliminate(rowclues.at(ri), row(ri), "Row #" + std::to_string(ri))) {
          effect = true;
          if (s_debug) { std::cout << "ELIMINATED FOR ROW " << ri << "\n"; dump(); }
        }
      }
      for (size_t ci = 0; ci<N; ++ci) {
        if (eliminate(colclues.at(ci), col(ci), "Col #" + std::to_string(ci))) {
          effect |= true;
          if (s_debug) { std::cout << "ELIMINATED FOR COL " << ci << "\n"; dump(); }
        }
      }

      return effect;
    }

    void solve() {
      preapply_hints();

      for (bool effect = true; effect;) {
        effect = false;
        effect |= solve_exclusive_options();
        effect |= solve_isolated_groups();
        effect |= eliminate_hinted_skylines(); // using hints again
      }
      if (s_debug) { dump(); }
    }

    void dump() {
      std::cout << "======== rows\n";
      std::cout << "     ";
      for (size_t ci = 0; ci<N; ++ci) 
        std::cout << std::setw(N+1) << ("[" + std::to_string(colclues.at(ci).forward) + "]     ");
      std::cout << "\n";
      for (size_t ri = 0; ri<N; ++ri)
      {
        std::cout << "[" << rowclues.at(ri).forward << "]  ";
        for(auto& cell : row(ri)) std::cout << cell << " ";
        std::cout << "  [" << rowclues.at(ri).backward << "]\n";
      }
      std::cout << "     ";
      for (size_t ci = 0; ci<N; ++ci) 
        std::cout << std::setw(N+1) << ("[" + std::to_string(colclues.at(ci).backward) + "]     ");
      std::cout << "\n";
    }

    option_seq&      row(size_t i)      { return field.at(i); }
    option_seq const& row(size_t i) const { return field.at(i); }

    struct colproxy {
      puzzle* _p;
      size_t _col;

      size_t size() const { return N; }

      option&      at    (size_t i)     { return _p->row(i).at(_col); }
      option const& at    (size_t i) const { return _p->row(i).at(_col); }
      option&      operator[](size_t i)     { return _p->row(i).at(_col); }
      option const& operator[](size_t i) const { return _p->row(i).at(_col); }

      struct it : std::iterator<std::bidirectional_iterator_tag, option> {
        it(colproxy* p, size_t i) : _p(p), _i(i){}

        using difference_type = std::ptrdiff_t;
        colproxy* _p;
        size_t _i;

        it& operator++() { ++_i; return *this; }
        it& operator--() { --_i; return *this; }
        bool operator==(it const& other) const { return _p == other._p && _i == other._i; }
        bool operator!=(it const& other) const { return _p != other._p || _i != other._i; }
        option& operator*() { return _p->at(_i); }
        option* operator->() { return &_p->at(_i); }
      };

      it begin() { return {this, 0}; }
      it end()   { return {this, N}; }
    };

    colproxy col(size_t i) { return { this, i }; }
  };
}

height decode(option const& cell) {
  switch(cell.to_ulong()) {
    case 1ul<<0: return h1;
    case 1ul<<1: return h2;
    case 1ul<<2: return h3;
    case 1ul<<3: return h4;
    case 1ul<<4: return h5;
    case 1ul<<5: return h6;
    case 1ul<<6: return h7;
    default: return none;
  }
}

std::vector<std::vector<int>> SolvePuzzle(std::vector<int> const& clues) {
  if (s_print_challenge) {
    std::cout << "{";
    for (auto i : clues) std::cout << i << ",";
    std::cout << "}\n";
  }

  using namespace utility;
  puzzle p(clues);
  p.solve();
  std::vector<std::vector<int> > r;

  for (auto& row : p.field) {
    r.emplace_back();
    for (auto& cell : row) {
      r.back().emplace_back(decode(cell));
    }
  }
  return r;
}
2 hours agoRefactor
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <map>
#include <vector>
#include <iostream>


using namespace std;

const int N = 7;
const int SIDES = 4;
const int MASK = (1 << N) - 1;
const int s[SIDES * N] = {0,1,2,3,4,5,6,6,13,20,27,34,41,48,48,47,46,45,44,43,42,42,35,28,21,14,7,0};
const int inc[SIDES * N] = {7,7,7,7,7,7,7,-1,-1,-1,-1,-1,-1,-1,-7,-7,-7,-7,-7,-7,-7,1,1,1,1,1,1,1};
int possible[N * N], results[N][N];
bool vis[N * N];
vector<int> my_clues;

void set_value(int x, int v) {
    int m = MASK ^ (1 << v);
    int s_row = x - x % N;
    int s_col = x % N;
    for (int i = 0; i < N; i++) {
        possible[s_row + i] &= m;
        possible[s_col + i * N] &= m;
    }
    possible[x] = 1 << v;
}

int check_unique() {
    int n_decides = 0;
    for (int i = 0; i < SIDES / 2 * N; i++) {
        map<int, vector<int> > possible_indices;
        for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
            for (int l = 0; l < N; l++) 
                if ((1 << l) & possible[j]) {
                    possible_indices[l].push_back(j);
                }
        }

        for (auto const &iter : possible_indices) {
            int val = iter.first;
            if (iter.second.size() == 1) {
                int idx = iter.second[0];
                if (possible[idx] != (1 << val)) {
                    n_decides++;
                    set_value(idx, val);
                }
            }
        }
    }
    return n_decides;
}

int filter2 () {
    int cnt = 0;
    for (int i = 0; i < SIDES * N; i++) {
        if (my_clues[i] == 2) {
            int mask = MASK;
            for (int l = N - 1; l >= 0; l--) {
                int m = (1 << l) & possible[s[i]];
                mask ^= 1 << l;
                if (m) break;
            }

            for (int j = s[i] + inc[i], k = 1; k < N; j += inc[i], k++) {
                int m = (1 << (N - 1)) & possible[j];
                if (m) break;
                if ((possible[j] | mask) != mask) {
                    possible[j] &= mask;
                    cnt++;
                }
            }
        }
    }
    return cnt;
}

int count_possible(int val) {
    int n = 0;
    while (val) {
        n += val & 1;
        val >>= 1;
    }
    return n;
}

bool valid() {
    for (int i = 0; i < SIDES * N; i++) {
        if (my_clues[i] == 0) continue;

        bool is_decided = true;
        for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
            if (count_possible(possible[j]) != 1) {
                is_decided = false;
                break;
            }
        }

        if (is_decided) {
            int largest = 0, n_clue = 0;
            for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
                if (largest < possible[j]) {
                    n_clue++;
                    largest = possible[j];
                }
            }
            if (n_clue != my_clues[i]) return false;
        }
    }

    return true;
}

void write_results() {
    for (int i = 0; i < N * N; i++) {
        int x = i / N, y = i % N;
        for (int j = 0; j < N; j++) {
            if ((1 << j) == possible[i]) {
                results[x][y] = j + 1;
                break;
            }
        }
    }
}

bool dfs(int idx) {
    int i = -1, tmp = 10000;
    for (int _i = 0; _i < N * N; _i++) {
        int c = count_possible(possible[_i]);
        if (tmp > c && !vis[_i]) {
            tmp = c;
            i = _i;
        }
    }

    if (i == -1) {
        if (valid()) {
            write_results();
            return true;
        }
        return false;
    }

    int possible_bak[N * N];
    memcpy(possible_bak, possible, sizeof(int) * N * N);

    for (int j = N - 1; j >= 0; j--) {

        int m = (1 << j) & possible[i];
        if (m == 0) continue;

        vis[i] = true;
        set_value(i, j);
        bool found = false;
        if (valid()) {
            found = dfs(idx + 1);
        }
        vis[i] = false;
        memcpy(possible, possible_bak, sizeof(int) * N * N);
        if (found) {
            return true;
        }
    }
    return false;
}

void init() {
    for (int i = 0; i < N * N; i++) {
        possible[i] = MASK;
        vis[i] = true;
    }
}

void pre_process() {
    for (int i = 0; i < SIDES * N; i++) 
    {
        if (my_clues[i] == 0) continue;
        for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
            int m = MASK;
            for (int l = N + k - my_clues[i] + 1; l < N; l++) m ^= 1 << l;
            possible[j] &= m;
        }
    }

    while (check_unique() > 0 );
    filter2();
}

vector<vector<int>> SolvePuzzle(const vector<int> &clues) {
    vector<vector<int>> r;
    init();
    my_clues = clues;

    pre_process();

    vector<pair<int, int>> idx_npos;
    for (int i = 0; i < N * N; i++) {
        int n_possible = count_possible(possible[i]);
        if (n_possible > 1) {
            vis[i] = false;
        }
    }

    dfs(0);

    for (int i = 0; i < N; i++) {
        vector<int> vec;
        for (int j = 0; j < N; j++) vec.push_back(results[i][j]);
        r.push_back(vec);
    }
    return r;
}
6 days agoRefactorDiscuss
6 kyu
Don't get stressed
JavaScript:
const pen_endings = ["ic", "sion", "tion", "ious"]
const anti_pen_endings = ["ty", "al", "ise", "ate"]

function stress(word) {
  let syllables = Number(word.replace(/[^\d]*/g, ""))
  let ending = word.replace(/[\d]*/g, "")
  
  if (syllables < 3 || syllables > 11) {
    return "invalid word"
  } else if (pen_endings.includes(ending)) {
    return `${syllables-1}pen`;
  } else if (anti_pen_endings.includes(ending)) {
    return `${syllables-2}ante-pen`;
  } else {
    return "invalid word"
  }
}
9 hours agoRefactorDiscuss
1 kyu
Mystery function #2
JavaScript:

function solved(x) {
  var h = 5381
  var n = x & x
  
  while (n != 0 && n != -1) {
    var c = x & 255
    n >>= 8
    h = ((h << 5) + h) + c
    h = h & h
  }
  
  return h ^ 5875174
}
9 hours agoRefactorDiscuss
1 kyu
Link Up--Play game Series #7
JavaScript:


function linkUp(gamemap){
  var init = [" ".repeat(10).split("")].concat(gamemap.split('\n').map(row => [' '].concat(row.split(' ')).concat([' ']))).concat([" ".repeat(10).split("")])
  var dirs = [[0,1],[1,0],[0,-1],[-1,0]];
  
  function search(arr, x, y) {
    var sols = [];
    const rec = (i, j, dir, lines) => {
      if (!arr[i] || !arr[i][j]) 
        return;
      if (arr[i][j] == ' ') {
        rec(i+dir[0], j+dir[1], dir, lines)
        if (lines <= 2) {
          dirs.forEach(([a,b]) => {
            if (!(a == dir[0] || b == dir[1])) {
              rec(i+a, j+b, [a,b], lines+1)
            }
          })
        }
      } else if (arr[i][j] == arr[x][y]) {
        sols.push([[x,y], [i,j]])
      }
    }
    
    dirs.forEach((dir,i) => rec(x+dir[0],y+dir[1], dir, 1))
    
    return sols;
  }
  
  function legalMoves(arr) {
    var start = [];
    for(i = 0; i<arr.length; i++) {
      for(j = 0; j<arr.length; j++) {
        var char = arr[i][j];
        if (char != ' ') {
          start = start.concat(search(arr, i, j))
        }
      }
    }
    return start;
  }
  
  function copyArr(arr) {
    var copy = [];
    arr.forEach(row => copy.push(row.map(x => x)))
    return copy;
  }
  
  var i = 0;
  var stop = false;
  var seen = {}
  var sol;
  
  function RECUR(arr, moves=[]) {
    if (stop || seen[""+arr])
      return;
    seen[""+arr] = true;
    if (moves.length == 32) {
      stop = true;
      sol = moves.map(([[x1,y1],[x2,y2]]) => [[x1-1,y1-1],[x2-1,y2-1]])
      return;
    }
    
    var start = legalMoves(arr)
    
    start.forEach(move => {
      var copy = copyArr(arr);
      
      let [[x1,y1],[x2,y2]] = move;
      copy[x1][y1] = ' ';
      copy[x2][y2] = ' ';
      
      RECUR(copy, moves.concat([move]))
    })
  }
  
  RECUR(init);
  
  return sol;
}
9 hours agoRefactorDiscuss
1 kyu
RoboScript #5 - The Final Obstacle (Implement RSU)
JavaScript:

class RSUProgram {
  constructor(source) {
    this._source = source;
  }
  getTokens() {
    let source = this._source, result = [];
    for (let i = 0; i < source.length; i++) {
      var token;
      switch (source[i]) {
        case 'F':
        case 'L':
        case 'R':
        case ')':
          token = source[i++];
          while (/\d/.test(source[i])) token += source[i++];
          i--;
          if (token.length > 2 && token[1] == '0') throw new SyntaxError('Invalid token detected');
          result.push(token);
          break;
        case '(':
        case 'q':
          result.push(source[i]);
          break;
        case 'p':
        case 'P':
          token = source[i++];
          while (/\d/.test(source[i])) token += source[i++];
          i--;
          if (token.length < 2 || (token.length > 2 && token[1] == '0')) throw new SyntaxError('Invalid token detected');
          result.push(token);
          break;
        case '/':
          if (source[i + 1] === '/') {
            while (source[i] != '\n' && i < source.length) i++;
          } else if (source[i + 1] === '*') {
            i++;
            while ((source[i + 1] != '*' || source[i + 2] != '/') && i < source.length - 2) i++;
            if (source[i + 1] != '*' || source[i + 2] != '/') throw new SyntaxError('Invalid token detected');
            i += 2;
          } else throw new SyntaxError('Invalid token detected');
          break;
        default:
          if (/[^\s\r\t\n]/.test(source[i])) throw new SyntaxError('Invalid token encountered');
      }
    }
    return result;
  }
  convertToRaw(tokens) {
    var _convert = function (tokens, patterns) {
      patterns = JSON.parse(JSON.stringify(patterns));
      var stack = [], decls = new Set();
      for (var i = 0; i < tokens.length; i++) {
        switch (tokens[i][0]) {
          case '(':
            stack.push(tokens[i]);
            break;
          case ')':
            if (stack.length && stack[stack.length - 1][0] === '(') stack.pop();
            else stack.push(tokens[i]);
            break;
          case 'p':
            if (stack.length && stack[stack.length - 1][0] === '(') throw new SyntaxError('Pattern definitions may not be nested within bracketed sequences!');
            if (!stack.length) {
              if (decls.has(tokens[i].toUpperCase())) throw new Error('A pattern may not be defined more than once in the same scope!');
              decls.add(tokens[i].toUpperCase());
            }
            stack.push(tokens[i]);
            break;
          case 'q':
            if (stack.length && stack[stack.length - 1][0] === 'p') stack.pop();
            else stack.push(tokens[i]);
            break;
        }
      }
      if (stack.length) throw new SyntaxError('Unmatched brackets and/or pattern definitions found');
      var result;
      for (var _ = 0; _ < 2; _++) {
        result = [];
        for (var i = 0; i < tokens.length; i++) {
          if (tokens[i][0] === 'p') {
            var pid = tokens[i].toUpperCase(), patternDefinition = [], unmatched = 1;
            while (unmatched) {
              i++;
              if (tokens[i][0] === 'p') unmatched++;
              else if (tokens[i][0] === 'q') unmatched--;
              if (tokens[i][0] != 'q' || unmatched) patternDefinition.push(tokens[i]);
            }
            try {
              patterns[pid] = _convert(patternDefinition, patterns);
            } catch (e) {}
          } else result.push(tokens[i]);
        }
      }
      for (var _ = 0; _ < 10; _++) {
        var temp = [];
        for (var i = 0; i < result.length; i++) {
          switch (result[i][0]) {
            case 'F':
            case 'L':
            case 'R':
              var repeats = result[i].slice(1).length ? +result[i].slice(1) : 1;
              for (var j = 0; j < repeats; j++) temp.push(result[i][0]);
              break;
            case '(':
              var subprogram = [], brackets = 1;
              while (brackets) {
                i++;
                if (result[i][0] === '(') brackets++;
                else if (result[i][0] === ')') brackets--;
                subprogram.push(result[i]);
              }
              subprogram.pop();
              var repeats = result[i].slice(1).length ? +result[i].slice(1) : 1;
              for (var j = 0; j < repeats; j++) temp.splice(temp.length, 0, ...subprogram);
              break;
            case 'P':
              if (typeof patterns[result[i]] != 'undefined') temp.splice(temp.length, 0, ...patterns[result[i]]);
              else temp.push(result[i]);
              break;
          }
        }
        if (temp.every(s => s === 'F' || s === 'L' || s === 'R')) return temp;
        result = temp;
      }
      return result;
    }, result = _convert(tokens, {});
    if (result.some(s => s !== 'F' && s !== 'L' && s !== 'R')) throw new Error('Something went wrong');
    return result;
  }
  executeRaw(cmds) {
    var code = cmds.join``;
    var directions = ["right", "down", "left", "up"];
    var directionIndex = 0;
    var grid = [[0]];
    var robot = {x: 0, y: 0};
    grid[robot.y][robot.x] = 1;
    for (var i = 0; i < code.length; i++) {
      switch (code[i]) {
        case "R":
        directionIndex = (directionIndex + 1) % 4;
        break;
        case "L":
        directionIndex = (directionIndex + 3) % 4;
        break;
        case "F":
        switch (directions[directionIndex]) {
          case "right":
          robot.x++;
          if (robot.x >= grid[robot.y].length) {
            for (var k = 0; k < grid.length; k++) grid[k].push(0);
          }
          break;
          case "down":
          robot.y++;
          if (robot.y >= grid.length) grid.push(Array(grid[0].length).fill(0));
          break;
          case "left":
          robot.x--;
          if (robot.x < 0) {
            for (var k = 0; k < grid.length; k++) grid[k] = [0].concat(grid[k]);
            robot.x++;
          }
          break;
          case "up":
          robot.y--;
          if (robot.y < 0) {
            grid = [Array(grid[0].length).fill(0)].concat(grid);
            robot.y++;
          }
          break;
        }
        grid[robot.y][robot.x] = 1;
        break;
      }
    }
    return grid.map(r => r.map(s => s === 1 ? "*" : " ").join("")).join("\r\n");
  }
  execute() {
    return this.executeRaw(this.convertToRaw(this.getTokens()));
  }
}
9 hours agoRefactorDiscuss
1 kyu
Peano and Church
Haskell:

{-# LANGUAGE 
  FlexibleInstances, 
  UndecidableInstances, 
  InstanceSigs,
  ScopedTypeVariables,
  RankNTypes #-}

module PC where

import Data.List

type ISO a b = (a -> b, b -> a)
-- See  AAAA ZIO https://www.codewars.com/kata/isomorphism

symm :: ISO a b -> ISO b a
symm (ab, ba) = (ba, ab)

substL :: ISO a b -> (a -> b)
substL = fst

substR :: ISO a b -> (b -> a)
substR = snd

liftISO2 :: ISO a b -> ISO (a -> a -> a) (b -> b -> b)
liftISO2 i@(ab, ba) = (lr, substL (liftISO2 (symm i)))
  where
    lr aaa lb rb = ab (aaa (ba lb) (ba rb))

-- A Natural Number is either Zero,
-- or a Successor (1 +) of Natural Number.
-- We have (+)/(*) on Natural Number, or (-) it.
-- Since Natrual Number do not have negative, forall x, 0 - x = 0.
-- We also have pow on Natrual Number
-- Since Haskell is lazy, we also have infinity

class Nat n where
  zero :: n
  successor :: n -> n
  nat :: a -> (n -> a) -> n -> a -- Pattern Matching
  iter :: a -> (a -> a) -> n -> a -- Induction
  plus, minus, mult, pow :: n -> n -> n
  inf :: n
  inf = successor inf
  divide :: n -> n -> n
  l `divide` r | l == 0 && r == 0 = undefined
  l `divide` r | l < r = 0
  l `divide` r | otherwise = successor $ (l `minus` r) `divide` r
  -- notice (l `divide` 0) when l is not 0 will return inf
  isoP :: ISO n Peano -- See below for the definition of Peano
  isoP = (iter zero successor, iter zero successor)
  toP :: n -> Peano
  toP = substL isoP

instance {-# OVERLAPPABLE #-} Nat n => Show n where
  show = show . toP

instance {-# OVERLAPPABLE #-} Nat n => Eq n where
  l == r = toP l == toP r

instance {-# OVERLAPPABLE #-} Nat n => Ord n where
  l `compare` r = toP l `compare` toP r

instance {-# OVERLAPPABLE #-} Nat n => Num n where
  abs = id
  signum = nat zero (const 1)
  fromInteger 0 = zero
  fromInteger n | n > 0 = successor $ fromInteger (n - 1)
  (+) = plus
  (*) = mult
  (-) = minus

-- We can encode Natrual Number directly as Algebraic Data Type(ADT).
data Peano = O | S Peano deriving (Show, Eq, Ord)

-- Remember, 0 - x = 0 for all x.
instance Nat Peano where
  zero = O
  successor = S
  nat z _ O = z
  nat _ s (S n) = s n
  iter z _ O = z
  iter z f (S x) = f $ iter z f x
  plus O = id
  plus (S n) = S . plus n
  O `mult` _ = O
  S l `mult` r = r `plus` (l `mult` r)
  O `minus` _ = O
  l `minus` O = l
  S l `minus` S r = l `minus` r
  _ `pow` O = 1
  l `pow` S r = l * (l `pow` r)

-- Peano is very similar to a basic data type in Haskell - List!
-- O is like [], and S is like : (except it lack the head part)
-- When we want to store no information, we can use (), a empty tuple
-- This is different from storing nothing (called Void in Haskell),
-- as we can create a value of () by using (), 
-- but we cannot create a value of Void.

-- Notice how you can implement everything once you have isoP,
-- By converting to Peano and using Nat Peano?
-- Dont do that. You wont learn anything.
-- Try to use operation specific to list.
instance Nat [()] where
  zero = []
  successor = (():)
  nat z _ [] = z
  nat _ s (_:n) = s n
  iter z f = foldl (\a _ -> f a) z
  plus = (++)
  minus = (\\)
  mult = (>>)
  l `pow` r = foldl mult 1 (map (const l) r)

-- Instead of defining Nat from zero, successor (and get Peano),
-- We can define it from Pattern Matching
newtype Scott = Scott { runScott :: forall a. a -> (Scott -> a) -> a }
instance Nat Scott where
  zero = Scott const
  successor x = Scott $ const ($ x)
  nat z f (Scott x) = x z f
  iter z f (Scott x) = x z (f . iter z f)
  -- Other operation on Scott numeral is sort of boring,
  -- So we implement it using operation on Peano.
  -- You shouldnt do this - I had handled all the boring case for you.
  plus = substR (liftISO2 isoP) plus
  minus = substR (liftISO2 isoP) minus
  mult = substR (liftISO2 isoP) mult
  pow = substR (liftISO2 isoP) pow

-- Or from induction!
newtype Church = Church { runChurch :: forall a. (a -> a) -> a -> a }
instance Nat Church where
  zero = Church $ const id
  successor (Church x) = Church (\f -> f . (x f))
  nat z f (Church x) =
    maybe z f $ x (Just . maybe zero successor) Nothing
  iter z f (Church x) = x f z
  -- Try to implement the calculation (except minus) in the primitive way.
  -- Implement them by constructing Church explicitly.
  -- So plus should not use successor,
  -- mult should not use plus,
  -- exp should not use mult.
  Church l `plus` Church r = Church (\f x -> l f $ r f x)
  Church l `mult` Church r = Church (\f -> l $ r f)
  Church l `pow` Church r = Church $ r l
  l `minus` (Church r) = r (nat 0 id) l
9 hours agoRefactorDiscuss
1 kyu
Sloth
OCaml:

(* O CAMMELLO!!!!!!!!!!!! Let's implement laziness!
 * A lazy value can be implemented as a closure (also known as thunk),
 * and getting a strict value out of it is just function evaluation. *)

(* Note that you should not use reference unless we explicitly ask for it.
 * Also, whenever you construct a lazy value, make sure to defer
 * all calculation as late as possible *)
module type Lazy =
sig
  type _ t
  val mk: (unit -> 'a) -> 'a t
  val get: 'a t -> 'a
  val map: ('a -> 'b) -> 'a t -> 'b t
  val return: 'a -> 'a t
  val join: 'a t t -> 'a t
  val bind:  ('a -> 'b t) -> 'a t -> 'b t
  val (>>=): 'a t -> ('a -> 'b t) -> 'b t
  (* The argument is a lazy value that might refer to itself.
   * Tie the value to itself using reference. *)
  val tie: ('a t -> 'a t) -> 'a t
end;;

module type LazyMin =
sig
  type _ t
  val mk: (unit -> 'a) -> 'a t
  val get: 'a t -> 'a
end;;

module LazyImpl (LM: LazyMin): Lazy with type 'a t = 'a LM.t =
struct
  include LM
  let map f a = mk (fun _ -> f (get a))
  let return a = mk (fun _ -> a)
  let join a = mk (fun _ -> get (get a))
  let bind m a = join (map m a)
  let (>>=) a m = bind m a
  let tie f =
    let tem = ref (mk (fun _ -> failwith "uninitialize")) in
      tem := mk (fun _ -> get (f (!tem))); !tem
end;;

module LazyThunk: Lazy with type 'a t = unit -> 'a = LazyImpl(
struct
  type 'a t = unit -> 'a
  let mk f = f
  let get f = f ()
end);;

(* However, the thunk need to be evaluated each time get is used,
 * instead of at most once. This is outrageous! This is unfair!
 * It can be fixed by caching the result - the thunk is only evaluated
 * if the cache is empty. *)
module LazyOption:
  Lazy with type 'a t = 'a option ref * (unit -> 'a) = LazyImpl(
struct
  type 'a t = 'a option ref * (unit -> 'a)
  let mk f = (ref None, f)
  let get (o, f) =
    match !o with
      None -> let ret = f () in o := Some ret; ret
    | Some x -> x
end);;

(* Notice how there is two components for a Lazy: a thunk and a cache.
 * Here is a pretty cool trick: instead of having two components,
 * just cache the thunk!
 * This is called tagless because we no longer use algebraic data type,
 * which tag the value.
 * We just have a uniform way to handle the value. *)
module LazyTagless: Lazy with type 'a t = (unit -> 'a) ref = LazyImpl(
struct
  type 'a t = (unit -> 'a) ref
  let mk = ref
  let get x = let ret = (!x)() in x := (fun _ -> ret); ret
end);;
(* Notice how most definition of lazy can be derived from other?
 * Try to lookup how module works and refactor them. *)

(* To test that implementation work, do some infinite stream *)
module type StreamSig =
sig
  module L: Lazy
  type 'a stream = Stream of ('a * 'a stream) L.t
  val mk: (unit -> 'a * 'a stream) -> 'a stream
  val hd: 'a stream -> 'a
  val tl: 'a stream -> 'a stream
  val gen: ('a -> 'a) -> 'a L.t -> 'a stream
  val map: ('a -> 'b) -> 'a stream -> 'b stream
  val zip: 'a stream -> 'b stream -> ('a * 'b) stream
  val zipWith: ('a * 'b -> 'c) -> 'a stream -> 'b stream -> 'c stream
  val takeWhile: ('a -> bool) -> 'a stream -> 'a list
  val app: 'a list -> 'a stream -> 'a stream
  val fib_aux: int stream -> int stream (*fib = tie fib_aux*)
  val join: 'a stream stream -> 'a stream
end;;

module Stream (L: Lazy): StreamSig with module L = L =
struct
  module L = L
  type 'a stream = Stream of ('a * 'a stream) L.t
  let rec mk f = Stream (L.mk f)
  let hd (Stream x) = fst (L.get x)
  let tl (Stream x) = mk (fun _ ->
    match snd (L.get x) with Stream s -> L.get s)
  let rec gen f a = mk (fun _ ->
    (L.get a, gen f (L.mk (fun _ -> f (L.get a)))))
  let rec map f x = mk (fun _ -> (f (hd x), map f (tl x)))
  let rec zip l r = mk (fun _ -> ((hd l, hd r), zip (tl l) (tl r)))
  let zipWith f l r = map f (zip l r)
  let rec takeWhile p x = if p (hd x) then hd x :: takeWhile p (tl x) else []
  let rec app = function
    [] -> (fun x -> x)
  | (a :: ax) -> (fun x -> mk (fun _ -> (a, (app ax x))))
  let fib_aux self =
    app [0; 1] (zipWith (fun (l, r) -> l + r) self (tl self))
  let join ss =
    let rec fold l s =
      mk (fun () -> L.get (match (app (List.map hd l) (fold (hd s :: List.map tl l) (tl s))) with
        Stream s -> s)) 
    in fold [] ss
end;;
9 hours agoRefactorDiscuss
1 kyu
One function, many arguments: Haskell style.
Haskell:

{-# LANGUAGE FlexibleInstances,
             FlexibleContexts,
             UndecidableInstances,
             FunctionalDependencies,
             TypeFamilies #-}
module PolyvariadicFunctions where

class Variadic a r t | t -> r where
  liftVariadic :: ([a] -> r) -> t

instance Variadic a r r where
  liftVariadic f = f []

instance (a ~ a', Variadic a r t) => Variadic a r (a' -> t) where
  liftVariadic f h = liftVariadic (f . (h:))

polyAdd :: Variadic Int Int t => t
polyAdd = liftVariadic (sum :: [Int] -> Int)

polyWords :: Variadic String String t => t
polyWords = liftVariadic unwords

polyList :: Variadic a [a] t => t
polyList = liftVariadic id
9 hours agoRefactorDiscuss
1 kyu
Hack-22
Java:

import java.lang.reflect.*;
import java.lang.instrument.*;
import java.io.*;
import java.nio.file.*;
import java.net.*;
import java.security.*;
import java.util.zip.*;
import java.lang.management.*;

public class Catch22 extends Yossarian {
  static Instrumentation m_inst;

  public static Yossarian loophole() throws Throwable {
      File javaHomeFile = new File(System.getProperty("java.home")).getParentFile();
      File toolsJar = new File(javaHomeFile, "lib/tools.jar");
      System.out.println(toolsJar);
      
      ClassLoader loader = Thread.currentThread().getContextClassLoader();
      loader = new URLClassLoader(new URL[] { toolsJar.toURI().toURL() }, loader);
      String vmClassName = "com.sun.tools.attach.VirtualMachine";
      Class vmClass = loader.loadClass(vmClassName);
      
      CodeSource cs = Catch22.class.getProtectionDomain().getCodeSource();
      
      File agentJar = new File(cs.getLocation().getFile());
      File[] listOfFiles = agentJar.listFiles();
      System.out.println();
      for (int i = 0; i < listOfFiles.length; i++)
          if (listOfFiles[i].isFile())
              System.out.println(listOfFiles[i].getName());
      System.out.println();
      
      File yossFile = new File(cs.getLocation().getFile(), "/Yossarian.class");
      Path yossPath = Paths.get(yossFile.getAbsolutePath());
      byte[] bytecode = Files.readAllBytes(yossPath);
      
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < bytecode.length; i++) {
          sb.append(String.format("%02X ", bytecode[i]));
          sb.append(" ");
      }
      System.out.println(sb.toString());
      System.out.println();
      
              
      File jar = File.createTempFile(Catch22.class.getName(), ".jar");
      jar.deleteOnExit();
      ZipOutputStream zout = new ZipOutputStream(new FileOutputStream(jar));
      zout.putNextEntry(new ZipEntry("META-INF/MANIFEST.MF"));
      PrintWriter writer = new PrintWriter(new OutputStreamWriter(zout));
      writer.println("Agent-Class: " + Catch22.class.getName());
      writer.println("Can-Redefine-Classes: true");
      writer.println("Can-Retransform-Classes: true");
      writer.close();
      System.out.println(jar.getAbsolutePath());
      
      RuntimeMXBean runtime = ManagementFactory.getRuntimeMXBean();
      String rname = runtime.getName();
      String pid = rname.substring(0, rname.indexOf("@"));
      
      Object vm = vmClass.getMethod("attach", new Class<?>[] { String.class }).invoke(null, new Object[] { pid });
      System.out.println(vm);
      System.out.println();
      vmClass.getMethod("loadAgent", new Class[] { String.class }).invoke(vm, new Object[] { jar.getAbsolutePath() });
      vmClass.getMethod("detach", new Class[] {}).invoke(vm, new Object[] {});
      
      // iconst_0 -> iconst_1
      bytecode[220] = (byte)0x04;
      
      ClassDefinition def = new ClassDefinition(Yossarian.class, bytecode);
      m_inst.redefineClasses(def);
      
      return new Catch22();
  }
  
  public static void agentmain(String agentArgs, Instrumentation inst) {
      System.out.println("The ham is in the sandwich.");
      System.out.println(inst);
      System.out.println();
      m_inst = inst;
  }
}
9 hours agoRefactorDiscuss
1 kyu
Square sums
CoffeeScript:

is_square = (x)->
  !(Math.sqrt(x)%1)

get_links = (x,n)->
  i for i in [0..n] when i!=x and is_square i+x

max_t = 10000

#=======================================================================
# Cache links in arrays, pool in sparse array, check if pool is valid
#
square_sums_row_2p = (n)->
  links = [[]]
  links[x] = [(get_links x,n)...] for x in [1..n]
  tick = 0
  search = (pool,head,ends)->
    ++tick
    throw new Error 'timeout' if tick>max_t
    x = head[0]
    ls = if head.length then links[x] else [1..n]
    ls.sort (a,b)->pool[a]-pool[b]
    for y in ls when pool[y]
      if head.length < n-1
        e = ends
        p = pool[..]
        if p[y] is 1 then --e
        dead = no
        for z in links[y] when p[z]
          --p[z]
          if p[z] is 0
            dead = yes
            break
          else if p[z] is 1
            ++e
        continue if e>1 or dead
        p[y]=0
        o = search p, [y].concat(head), e
        return o if o
      else return [y].concat head
    no

  pool = (l.length for l in links)
  pool[0]=0
  ends = 0
  for l,i in links when i
    switch l.length
      when 0
        return no
      when 1
        ++ends
        if ends > 2
          return no
  try
    search pool, [], ends
  catch e
    undefined



#=======================================================================
# Cache links in arrays, pool in sparse array, check if pool is valid
# Expand 2-way. Seems to be slower than 2p.
# Reason: first node selected is the most possible end (least connections).
# Expanding it 2 ways makes it the middle, which contradicts the heuristic.
#
square_sums_row_3 = (n)->
  links = [[]]
  links[x] = [(get_links x,n)...] for x in [1..n]
  tick = 0
  search = (pool,head,ends)->
    ++tick
    throw new Error 'timeout' if tick>max_t
    if head.length
      ls = links[head[0]]
      rs = links[head[head.length-1]]
    else
      ls = [1..n]
      rs = []
    ms = ([0,l] for l in ls).concat ([1,r] for r in rs)
    ms.sort (a,b)->pool[a[1]]-pool[b[1]]

    for [d,y] in ms when pool[y]
      if head.length < n-1
        e = ends
        p = pool[..]
        if p[y] is 1 then --e
        dead = no
        for z in links[y] when p[z]
          --p[z]
          if p[z] is 0
            dead = yes
            break
          else if p[z] is 1
            ++e
        continue if e>1 or dead
        p[y]=0
        o = search p, (if d then head.concat [y] else [y].concat head), e
        return o if o
      else return (if d then head.concat [y] else [y].concat head)
    no

  pool = (l.length for l in links)
  pool[0]=0
  ends = 0
  for l,i in links when i
    switch l.length
      when 0
        return no
      when 1
        ++ends
        if ends > 2
          return no
  try
    search pool, [], ends
  catch e
    undefined



#=======================================================================
# Cache links in arrays, pool in sparse array, check if pool is valid
# Expand 2-way, but heaviest first
#
square_sums_row_3a = (n)->
  links = [[]]
  links[x] = [(get_links x,n)...] for x in [1..n]
  tick = 0
  search = (pool,head,ends)->
    ++tick
    throw new Error 'timeout' if tick>max_t
    if head.length
      ls = links[head[0]]
      rs = links[head[head.length-1]]
      ms = ([0,l] for l in ls).concat ([1,r] for r in rs)
      ms.sort (a,b)->pool[a[1]]-pool[b[1]]
    else
      ms = ([0,l] for l in [1..n])
      ms.sort (a,b)->pool[b[1]]-pool[a[1]]

    for [d,y] in ms when pool[y]
      if head.length < n-1
        e = ends
        p = pool[..]
        if p[y] is 1 then --e
        dead = no
        for z in links[y] when p[z]
          --p[z]
          if p[z] is 0
            dead = yes
            break
          else if p[z] is 1
            ++e
        continue if e>1 or dead
        p[y]=0
        o = search p, (if d then head.concat [y] else [y].concat head), e
        return o if o
      else return (if d then head.concat [y] else [y].concat head)
    no

  pool = (l.length for l in links)
  pool[0]=0
  ends = 0
  for l,i in links when i
    switch l.length
      when 0
        return no
      when 1
        ++ends
        if ends > 2
          return no
  try
    search pool, [], ends
  catch e
    undefined

#=======================================================================
# Try solutions
#
square_sums_row = (n)->
  max_t = 30*n
  square_sums_row_2p(n) ? square_sums_row_3(n) ? square_sums_row_3a(n)
9 hours agoRefactorDiscuss
1 kyu
Sliding Puzzle Solver
Python:
class Solver:
    def __init__(self, n, puzzle):
        self.n = n
        self.tiles = {}
        for r in range(n):
            for c in range(n):
                self.tiles[r, c] = puzzle[r][c]
        self.neighbours = {}
        for r in range(n):
            for c in range(n):
                neighs = []
                for (dr, dc) in [(-1, 0), (0, -1), (0, 1), (1, 0)]:
                    neigh = (r + dr, c + dc)
                    if neigh in self.tiles:
                        neighs.append(neigh)
                self.neighbours[r, c] = neighs[:]
        self.manhDist = {}
        for (r1, c1) in self.neighbours:
            for (r2, c2) in self.neighbours:
                self.manhDist[r1, c1, r2, c2] = abs(r1 - r2) + abs(c1 - c2)
        self.answer = []

    def solved(self):
        for (r, c) in self.tiles:
            if r == self.n - 1 and c == self.n - 1:
                if self.tiles[r, c] != 0:
                    return False
            elif r * self.n + c + 1 != self.tiles[r, c]:
                return False
        return True

    def solve(self):
        for i in range(self.n):
            self.solveRow(i)
            if self.solved():
                break
            self.solveColumn(i)
            if self.solved():
                break
        return self.answer

    def findTile(self, tile):
        for (r, c) in self.tiles:
            if self.tiles[r, c] == tile:
                return (r, c)

    def solveRow(self, r):
        for c in range(r, self.n - 2):
            self.solveTile((r, c), r * self.n + c + 1)
        last_1 = (r + 1) * self.n
        last_1pos = (r + 1, self.n - 1)
        last_2 = last_1 - 1
        last_2pos = (r, self.n - 1)
        bottom_right = (self.n - 1, self.n - 1)
        self.solveTile(bottom_right, last_1, [], True)
        self.solveTile(last_2pos, last_2, [], True)
        self.solveTile(last_1pos, last_1, [last_2pos], True)
        self.moveBlank(r, self.n - 2, [last_1pos, last_2pos])
        for c in range(self.n - 2, self.n):
            self.solveTile((r, c), r * self.n + c + 1)

    def solveColumn(self, c):
        for r in range(c + 1, self.n - 2):
            self.solveTile((r, c), r * self.n + c + 1)
        last_1 = self.n * (self.n - 1) + c + 1
        last_1pos = (self.n - 1, c + 1)
        last_2 = last_1 - self.n
        last_2pos = (self.n - 1, c)
        bottom_right = (self.n - 1, self.n - 1)
        self.solveTile(bottom_right, last_1, [], True)
        self.solveTile(last_2pos, last_2, [], True)
        self.solveTile(last_1pos, last_1, [last_2pos], True)
        self.moveBlank(self.n - 2, c, [last_1pos, last_2pos])
        for r in range(self.n - 2, self.n):
            self.solveTile((r, c), r * self.n + c + 1)

    def solveTile(self, destPos, targetTile, lockedPos = [], temp = False):
        r, c = destPos
        while True:
            (rx, cx) = self.findTile(targetTile)
            if (rx, cx) == (r, c):
                break
            neighbours = self.neighbours[rx, cx]
            if rx > r and (rx - 1, cx) in neighbours:
                newr, newc = rx - 1, cx
            elif rx < r and (rx + 1, cx) in neighbours:
                newr, newc = rx + 1, cx
            elif cx > c and (rx, cx - 1) in neighbours:
                newr, newc = rx, cx - 1
            elif cx < c and (rx, cx + 1) in neighbours:
                newr, newc = rx, cx + 1
            self.moveBlank(newr, newc, lockedPos + [(rx, cx)])
            self.moveTile(rx, cx, newr, newc)
        if not temp:
            for neighbour in self.neighbours[r, c]:
                self.neighbours[neighbour].remove((r, c))
            self.neighbours[r, c] = []

    def moveBlank(self, r, c, lockedPos):
        (rx, cx) = self.findTile(0)
        path = self.findPath(rx, cx, r, c, lockedPos)
        if path:
            for neighbourPos in path[1:]:
                neighbourTile = self.tiles[neighbourPos]
                self.tiles[neighbourPos] = 0
                self.tiles[rx, cx] = neighbourTile
                self.answer += [neighbourTile]
                rx, cx = neighbourPos

    def moveTile(self, oldr, oldc, newr, newc):
        neighbourTile = self.tiles[oldr, oldc]
        self.tiles[oldr, oldc] = 0
        self.tiles[newr, newc] = neighbourTile
        self.answer += [neighbourTile]

    def findPath(self, oldr, oldc, newr, newc, lockedPos):
        queue = [[0, (oldr, oldc), [(oldr, oldc)]]]
        while queue:
            thisNode = queue.pop(0)
            dist, thisPos, path = thisNode
            for neighPos in self.neighbours[thisPos]:
                if neighPos not in lockedPos:
                    if neighPos == (newr, newc):
                        return path[:] + [neighPos]
                    if neighPos not in path:
                        nr, nc = neighPos
                        dist = self.manhDist[nr, nc, newr, newc]
                        queue.append([dist, neighPos, path[:] + [neighPos]])
            queue.sort(key = lambda q: q[0])

def slide_puzzle(puzzle):
    n = len(puzzle)

    # check solvability
    size = n * n - 1
    flat = [x for row in puzzle for x in row if x != 0]
    inversions = sum(flat[i] > x for i in range(size) for x in flat[i + 1:])
    for r in range(n):
        if 0 in puzzle[r]:
            zeroRow = r
            break
    if n % 2 == 1:
        if inversions % 2 == 1: return None
    else:
        if inversions % 2 == (n - zeroRow) % 2: return None

    # set up solver
    solver = Solver(n, puzzle)
    answer = solver.solve()
    return answer
6 days agoRefactorDiscuss
JavaScript:

function slidePuzzle(p){
    const N = p.length, result = [], ? = {'U':[-1,0],'D':[1,0],'L':[0,-1],'R':[0,1]},
    R=[...Array(N).keys()],set=new Set(),j=(r,c)=>[r,c].join(','),
    
    // utility functions
    manh =(r,c,R,C,a=Math.abs)=>a(R-r)+a(C-c),
    xpos =x=> { for(let r of R)for(let c of R)if(p[r][c] === x)return[r,c] },
    safe =(r,c)=> r >= 0 && r < N && c >= 0 && c < N && !set.has(j(r,c)),
    move =(d,[r,c]=xpos(0))=>{const D=?[d],R=D[0]+r,C=D[1]+c,t=p[r][c];p[r][c]=p[R][C],p[R][C]=t;result.push(p[r][c])},
    mov0 =(r,c,p0hb={})=> {
      while(p[r][c] !== 0){
        const [R,C]=xpos(0),x=j(R,C),l=[]
        if (x in p0hb) p0hb[x]++; else p0hb[x] = 1
        for (let d in ?) {
          const D=?[d],Y=R+D[0],X=C+D[1],y=p0hb[j(Y,X)] 
          if (safe(Y,X)) l.push([y|0,manh(r,c,Y,X),d])
        }
        l.sort()
        move(l[0][2])
      }
    },
    movx =(x,r,c,pxhb=new Set())=> {
      while (p[r][c] !== x) {
        const [R,C] = xpos(x), t = j(R,C), l = []
        pxhb.add(t); set.add(t)
        for (let d in ?) {
          const D=?[d],Y=R+D[0],X=C+D[1]
          if (safe(Y,X)) l.push([manh(r,c,Y,X),Y,X])
        }
        l.sort()
        let y = 0, L = l.length
        while (y < L && pxhb.has(j(l[y][1],l[y][2]))) y++
        if (L > y) {
          mov0(l[y][1],l[y][2])
          set.delete(t)
          mov0(R,C)
        }
      }
    },
    xflip =()=> [...'LURRDLULDRRULLDRULDR'].forEach(d=> move(d)),
    yflip =()=> [...'DDLURULDDRUULDRULD'].forEach(d=> move(d))
    // end utility functions
    
    
    // solve the top N-2 rows
    let x = 0, Z = N-2
    for (let r = 0; r < Z; r++) {
      for (let c = 0; c < Z; c++) {
        let J = j(r,c)
        x++ // x belonds in p[r][c]
        if (p[r][c] === x) { set.add(J); continue }
        if (!set.has(J)) { movx(x,r,c); set.add(J);}
      }
      x += 2
      movx(x,r,Z)
      
      movx(x-1,r+1,Z)
      set.add(j(r+1,Z))
      set.add(j(r,Z))
      mov0(r,N-1)
      
      set.delete(j(r,Z));     set.delete(j(r+1,Z))
      move('L');              move('D')
      set.add(j(r,N-1));      set.add(j(r,Z))
      
      if (p[r][Z] === x-1 && p[r+1][Z] === 0 && p[r+1][N-1] === x) {
          move('R')             
          move('U')
          yflip()
      }
    }
//     finish the last 2 rows starting from the left
    for (let c = 0; c < Z; c++) {
      let t = N*Z+c+1, b = N*(N-1)+c+1
      if (p[Z][c] === t && p[N-1][c] === b) {
        set.add(j(Z,c)); set.add(j(N-1,c))
        continue
      }
      movx(t,N-1,c)
      // case 1
      if (p[Z][c] === 0 && p[Z][c+1] === b) {
        move('R');  move('D')
        xflip()
        set.add(j(Z,c));  set.add(j(N-1,c))
      }
      // case 2
      else if (p[Z][c] === b) {
        mov0(N-1,c+1)
        xflip()
        set.add(j(Z,c)); set.add(j(N-1,c));
      }
      else {
        set.add(j(N-1,c));
        movx(b,N-1,c+1)
        set.add(j(N-1,c+1))
        mov0(Z,c)
        set.delete(j(N-1,c))
        set.delete(j(N-1,c+1))
        move('D'); move('R')
        set.add(j(Z,c))
        set.add(j(N-1,c))
      }
    }
    mov0(N-1,N-1)
    while (p[N-1][Z] !== N*N-1)
      [...'LURD'].forEach(d=>move(d))
    
    return p[Z][Z] > p[Z][N-1] ? null : result
}
9 hours agoRefactorDiscuss
1 kyu
Mine Sweeper
JavaScript:

function solveMine(map, n) {
    const solver = new Solver(map, n);
    return solver.solve();
}

class Solver {
    constructor(map, totalMines) {
        this.totalMines = totalMines;
        this.grid = new Grid(map);
        this.constraints = new Constraints(this.grid, totalMines);
    }

    solve() {
        this.solveBasic();

        if (this.constraints.length === 0) {
            return this.grid.toString();
        }

        const solutions = this.findAllSolutions();

        if (solutions.length > 0) {
            this.flag(solutions.knownMines);
            this.open(solutions.knownEmpty);

            if (solutions.knownMines.length > 0 || solutions.knownEmpty.length > 0) {
                return this.solve();
            }
        }

        return '?';
    }

    solveBasic() {
        let changed = false;

        this.constraints.forEach(c => {
            if (c.total === 0) {
                this.open(c.cells);
                changed = true;
            }

            if (c.total === c.length) {
                this.flag(c.cells);
                changed = true;
            }
        });

        if (changed) {
            this.constraints.reduce();
            this.solveBasic();
        }
    }

    findAllSolutions() {
        let solutions = new Solutions();

        const search = (fringe) => {
            const solution = fringe.clone();
            const unsolvedCell = fringe.unsolvedCell;

            if (!unsolvedCell) {
                solutions.push(solution);
                return;
            }

            for (let i = 0; i <= 1; i++) {
                solution.set(unsolvedCell, i);

                if (!solution.meetsConstraints(this.constraints)) {
                    continue;
                }

                search(solution);
            }
        };

        search(Fringe.create(this.grid));

        return solutions;
    }

    open(cells) {
        cells.slice().forEach(cell => {
            const [row, col] = cell;
            this.grid.open(row, col);
            this.constraints.removeCell(row, col);
            this.constraints.addFromCell(this.grid, row, col);
        });
    }

    flag(cells) {
        cells.slice().forEach(cell => {
            const [row, col] = cell;
            this.grid.flag(row, col);
            this.constraints.flagCell(row, col);
        });
    }
}

class Constraints {
    constructor(grid, totalMines) {
        this.constraints = [];

        const covered = [];

        grid.forEach((row, col) => {
            if (grid.isOpened(row, col)) {
                this.addFromCell(grid, row, col);
            }

            if (grid.isCovered(row, col)) {
                covered.push([row, col]);
            }
        });

        this.add(covered, totalMines);

        this.reduce();
    }

    get length() {
        return this.constraints.length;
    }

    add(cells, value) {
        if (cells.length > 0) {
            this.constraints.push(new Constraint(cells, value));
        }
    }

    addFromCell(grid, row, col) {
        let value = grid.valueAt(row, col);
        let cells = [];

        grid.forEachNeighbor(row, col, (i, j) => {
            if (grid.isCovered(i, j)) {
                cells.push([i, j]);
            }

            if (grid.isFlagged(i, j)) {
                value--;
            }
        });

        this.add(cells, value);
    }

    reduce() {
        for (let i = 0; i < this.constraints.length; i++) {
            for (let j = 0; j < this.constraints.length; j++) {
                if (i === j) continue;

                const a = this.constraints[i];
                const b = this.constraints[j];
                if (a.isSubsetOf(b)) {
                    b.removeCells(a.cells);
                    b.total -= a.total;
                }
            }
        }

        this.constraints = this.constraints.filter(c => c.length > 0);
    }

    removeCell(row, col, flag = false) {
        this.forEach(c => c.remove(row, col, flag));
    }

    flagCell(row, col) {
        this.removeCell(row, col, true);
    }

    forEach(cb) {
        this.constraints.forEach((c, i) => cb(c, i));
    }
}

class Constraint {
    constructor(cells, total) {
        this.cells = cells;
        this.total = total;
    }

    get length() {
        return this.cells.length;
    }

    isSubsetOf(constraint) {
        return this.cells.every(cell => constraint.indexOf(...cell) !== -1);
    }

    indexOf(row, col) {
        return this.cells.findIndex(cell => cell[0] === row && cell[1] === col);
    }

    remove(row, col, flag = false) {
        const index = this.indexOf(row, col);
        if (index !== -1) {
            this.cells.splice(index, 1);

            if (flag) {
                this.total--;
            }
        }
    }

    removeCells(cells) {
        cells.forEach(cell => this.remove(...cell));
    }
}

class Solutions {
    constructor() {
        this.fringes = [];
        this.empty = {};
        this.mines = {};
    }

    get length() {
        return this.fringes.length;
    }

    get knownMines() {
        const mines = [];

        for (let key in this.mines) {
            const cell = key.split(',').map(Number);
            if (this.mines[key] === 1) {
                mines.push(cell);
            }
        }

        return mines;
    }

    get knownEmpty() {
        const empty = [];

        for (let key in this.empty) {
            const cell = key.split(',').map(Number);
            if (this.empty[key] === 0) {
                empty.push(cell);
            }
        }

        return empty;
    }

    push(fringe) {
        this.fringes.push(fringe);

        if (this.fringes.length === 1) {
            for (let cell in fringe.cells) {
                this.empty[cell] = 0;
                this.mines[cell] = 1;
            }
        }

        for (let cell in fringe.cells) {
            this.empty[cell] |= fringe.cells[cell];
            this.mines[cell] &= fringe.cells[cell];
        }
    }
}

class Fringe {
    constructor(cells = []) {
        this.cells = {};

        cells.forEach(c => {
            this.cells[c] = null;
        });
    }

    static create(grid) {
        const cells = [];

        grid.forEach((row, col) => {
            if (grid.isFringe(row, col)) {
                cells.push([row, col]);
            }
        });

        return new Fringe(cells);
    }

    clone() {
        const fringe = new Fringe();
        fringe.cells = Object.assign({}, this.cells);
        return fringe;
    }

    meetsConstraints(constraints) {
        let valid = true;

        constraints.forEach(c => {
            valid = valid && this.meetsConstraint(c);
        });

        return valid;
    }

    meetsConstraint(constraint) {
        let total = 0;
        let found = 0;

        for (let cell in this.cells) {
            const [row, col] = cell.split(',').map(Number);
            const value = this.cells[cell];

            if (value !== null && constraint.indexOf(row, col) > -1) {
                found++;
                total += value;

                if (total > constraint.total) {
                    return false;
                }
            }
        }

        if (found === constraint.length && total !== constraint.total) {
            return false;
        }

        return true;
    }

    set(cell, value) {
        this.cells[cell] = value;
    }

    get unsolvedCell() {
        let unsolvedCell = null;

        for (let cell in this.cells) {
            if (this.cells[cell] === null) {
                unsolvedCell = cell;
                break;
            }
        }

        return unsolvedCell;
    }
}

class Grid {
    constructor(map) {
        this.grid = map.split('\n').map(row => {
            return row.split(' ').map(value => value === '?' ? this.COVERED : +value);
        });
    }

    get FLAGGED() { return 9; }
    get COVERED() { return -1; }

    toString() {
        return this.grid.map((row, i) => {
            return row.map((value, j) => {
                if (this.isFlagged(i, j)) return 'x';
                if (this.isCovered(i, j)) return '?';
                return value;
            }).join(' ');
        }).join('\n');
    }

    open(row, col) {
        this.grid[row][col] = +open(row, col);
    }

    flag(row, col) {
        this.grid[row][col] = this.FLAGGED;
    }

    isFlagged(row, col) {
        return this.valueAt(row, col) === this.FLAGGED;
    }

    isCovered(row, col) {
        return this.valueAt(row, col) === this.COVERED;
    }

    isOpened(row, col) {
        return !this.isFlagged(row, col) && !this.isCovered(row, col);
    }

    isFringe(row, col) {
        if (!this.isCovered(row, col)) return false;

        let isFringe = false;
        this.forEachNeighbor(row, col, (i, j) => {
            isFringe = isFringe || this.isOpened(i, j);
        });

        return isFringe;
    }

    valueAt(row, col) {
        return this.grid[row][col];
    }

    forEach(cb) {
        this.grid.forEach((row, i) => {
            row.forEach((value, j) => cb(i, j, value));
        });
    }

    forEachNeighbor(row, col, cb) {
        for (let i = -1; i < 2; i++) {
            for (let j = -1; j < 2; j++) {
                if (i === 0 && j === 0) continue;

                if (this.inGrid(row + i, col + j)) {
                    cb(row + i, col + j, this.valueAt(row + i, col + j));
                }
            }
        }
    }

    inGrid(row, col) {
        return row >= 0 && row < this.grid.length
            && col >= 0 && col < this.grid[0].length;
    }
}
9 hours agoRefactorDiscuss
1 kyu
Four Pass Transport
Python:
from itertools import permutations,starmap
from heapq import *
from collections import defaultdict
from time import time

DT = defaultdict(int)
        
def timer(f):
    def w(*a):
        s = time()
        ans = f(*a)
        DT[f.__name__] += time()-s
        return ans
    return w
    
    

INF   = float("inf")
MOVES2 = {'E': (0,1), 'W': (-1,0), 'N': (0,-1), 'S': (1,0) }
         
CYCLES_PRECEDENCE = {
        ( 1, 0): "WNES,ENWS",
        ( 1, 1): "SWNE,ENWS",
        ( 0, 1): "SWNE,NWSE",
        (-1, 1): "ESWN,NWSE",
        (-1, 0): "ESWN,WSEN",
        (-1,-1): "NESW,WSEN",
        ( 0,-1): "NESW,SENW",
        ( 1,-1): "WNES,SENW"
}

@timer
def ref_fn(stations):
    print(stations)
    
    def dfs(iP, paths, n=0):
        if n==3: yield paths
        else:
            p1,p2 = pts[iP[n]:iP[n]+2]
            for moves in segMovesConfig[iP[n]]:
                path = aStar2(p1,p2,board,moves)
                if path is None: continue
                
                paths.append(path)
                for x,y in path: board[x][y] = 0
                yield from dfs(iP, paths, n+1)
                for x,y in path: board[x][y] = 1
                paths.pop()
                
    
    pts            = [divmod(s,10) for s in stations]
    MIN            = 1 + sum(manhattan(pts[i],pts[i+1]) for i in range(3))
    segMovesConfig = [ genOptimalAStarMoves(pts[i],pts[i+1]) for i in range(3)]
    shortestPath   = None
    
    for iP in permutations(range(3)):
        board = [[1]*10 for _ in range(10)]
        for x,y in pts: board[x][y] = 0
        
        for p in dfs(iP, []):
            length = 4 + sum(map(len,p))
            
            if not shortestPath or length < len(shortestPath):
                shortestPath = []
                for i,subp in sorted(zip(iP, p)):
                    shortestPath.append(linearize(pts[i]))
                    shortestPath.extend(map(linearize,subp))
                shortestPath.append(linearize(pts[i+1]))
                
            if len(shortestPath) == MIN:
                return shortestPath
    
    return shortestPath
    
    
def genOptimalAStarMoves(p1,p2):
    dx,dy = (b-a for a,b in zip(p1,p2))
    dir   = ( dx and dx//abs(dx), dy and dy//abs(dy) )
    
    return [ [MOVES2[d] for d in s] for s in CYCLES_PRECEDENCE[dir].split(",")]
    

def aStar2(p1,p2,board,moves):
    prev  = [[None]*10 for _ in range(10)]
    local = [[(INF,0) if free else (0,0) for free in r] for r in board]                # (cost+heuristic, rotation index)
    local[p2[0]][p2[1]] = (INF,0)
    
    q = [(manhattan(p1,p2), 0, 0, 0, p1)]                    # queue: (cost+h, rotation index, general index, cost, (x,y))
    iG = 0
    while q and q[0][-1] != p2:
        _,_,_,cost,src = heappop(q)
        cost += 1
        iG   -= 1
        for i,(dx,dy) in enumerate(moves):
            pos = a,b = src[0]+dx, src[1]+dy
            if 0<=a<10 and 0<=b<10:
                nTup  = (cost,i)
                if nTup < local[a][b]:
                    prev[a][b], local[a][b] = src, nTup
                    heappush(q, (cost + manhattan(pos,p2), i, iG, cost, pos))
    
    if q:
        p, (x,y) = [], p2
        while 1:
            x,y = pos = prev[x][y]
            if pos == p1: break
            p.append(pos)
        return p[::-1]




INF   = float("inf")
MOVES = [(0,1), (-1,0), (0,-1), (1,0)]        # Turn anticlockwise
ATTENUATION = 0.001

def vertical_dist(pos, p2):
    """
    tie breaker for preference of vertical paths
    """
    c_row, _ = pos
    e_row, _ = p2
    return abs(e_row - c_row) * ATTENUATION

def horizontal_dist(pos, p2):
    """
    tie breaker for preference of horizontal paths
    """
    _, c_col = pos
    _, e_col = p2
    return abs(e_col - c_col) * ATTENUATION


@timer
def four_pass(stations):
    def dfs(pOrder, paths, n=0):
        if n==3:
            yield paths[:]
        else:
            _, p1, p2 = pOrder[n]
            for tie_breaker_func in [vertical_dist, horizontal_dist]:
                path = aStar(p1, p2, board, tie_breaker_func)
                if path is None:
                    continue
                paths.append(path)
                updateBoard(board, path)
                yield from dfs(pOrder, paths, n+1)
                updateBoard(board, path, free=1)
                paths.pop()
    
    pts      = [divmod(s,10) for s in stations]
    segments = [(i, pts[i], pts[i+1]) for i in range(3)]
    MIN      = 1 + sum(manhattan(p1,p2) for _,p1,p2 in segments)
    
    shortestPath = None
    for pOrder in permutations(segments):
        board = [[1]*10 for _ in range(10)]
        updateBoard(board, pts)
        
        for p in dfs(pOrder, []):
            length = 4 + sum(map(len,p))
            
            if not shortestPath or length < len(shortestPath):
                shortestPath = rebuildPath(pOrder, p)
                
            if len(shortestPath) == MIN:
                return shortestPath
    
    return shortestPath
    
    

def manhattan(*args): return sum(abs(b-a) for a,b in zip(*args))
def linearize(p):     return 10*p[0]+p[1]

def updateBoard(board, inPath, free=0):
    for x,y in inPath: board[x][y] = free
    
def rebuildPath(pOrder, shortest):
    fullPath = []
    for (i,p1,p2),path in sorted(zip(pOrder, shortest)):
        fullPath.append(linearize(p1))
        fullPath.extend(map(linearize,path))
    fullPath.append(linearize(p2))
    return fullPath

def aStar(p1, p2, board, tie_breaker_func):
    prev  = [[None]*10 for _ in range(10)]
    # (heuristic, rotation index)
    local = [[INF if free else 0 for free in r] for r in board]
    local[p2[0]][p2[1]] = INF
    
    # queue: (cost+h, cost, (x,y))
    q = [(manhattan(p1, p2) + tie_breaker_func(p1, p2), 0, p1)]
    while q:
        _, cost, src = q.pop(q.index(min(q)))
        if src == p2:
            break
        x, y = src
        for a, b in ((x+dx, y+dy)
                     for i, (dx, dy) in enumerate(MOVES)
                     if 0 <= x + dx < 10 and 0 <= y + dy < 10):
            pos, nCost = (a, b), cost + 1
            if nCost < local[a][b]:
                prev[a][b], local[a][b] = src, nCost
                q.append((nCost + manhattan(pos, p2) + tie_breaker_func(pos, p2),
                             nCost, pos))
    if q:
        p, (x,y) = [], p2
        while 1:
            x,y = pos = prev[x][y]
            if pos == p1: break
            p.append(pos)
        return p[::-1]

print(four_pass([80, 8, 68, 21]))
6 days agoRefactorDiscuss
1 kyu
To BrainFuck Transpiler
JavaScript:

/**Given pseudocode, convert it to BF and output that code
 * @param code The pseudocode to translate
 * @param reg Optional paramater that contains any existing registers
 * @param p Optional parameter containing any procedures previously defined
 * @param checked A boolean representing whether input has already been properly parsed
 */
function kcuf(code, reg=[], p=[], checked=false) {
  var r='', c=code;//return String of translated code in r, c is shortening of code
  //due to its frequent use
  if(!checked)
  {
    for(var i=c.indexOf(" ["); i>0; i=c.indexOf(" ["))
      c=c.substring(0, i)+c.substring(i+1);//square brackets do not need spaces!
    for(var i=c.indexOf("[ "); i>0; i=c.indexOf("[ "))
      c=c.substring(0, i+1)+c.substring(i+2);
    for(var i=c.indexOf(" ]"); i>0; i=c.indexOf(" ]"))
      c=c.substring(0, i)+c.substring(i+1);//so smush them so "a  [ 20 ]" becomes "a[20]"
    c=c.replace(/  /g, " ").replace(/\t/g, "").split("\n");
    //get rid of all double spaces, tabs, and split each line of code into its own index
    for(var i=0; i<c.length; i++)//go through each line of code
    {
      var n=[], j, t;//new line of code, index to keep track of the end of a token
      //and a temporary value for general use
      while(c[i].length)//while there is code on this line to parse through
        if(c[i][0]==' ')//each token will be an element
          c[i]=c[i].substring(1);//so spaces may be discarded
        else if(c[i][0]=='"')//beginning of literal text token found
        {
          for(j=1; c[i][j]!='"'&&j<c[i].length; j++){}//find the corresponding "
          if(c[i][j]!='"')//if we didn't find another double quote
            throw "Not enough quotes!";//then we have an unclosed String literal!
          n.push(c[i].substring(0, ++j));//push the String with quotes
          c[i]=c[i].substring(j);//and delete the old token so it doesn't get re-parsed
        }
        else if(c[i][0]=="#"||c[i].startsWith("//")||c[i].startsWith("--"))//all comment indicators
          c[i]='';//ignore the rest of the line
        else//not a string literal or comment, token must be parsed in a unique way
        {
          for(j=1; j<c[i].length&&'" #/-'.indexOf(c[i][j])<0; j++){}//go until we find
          //a double quote (start of string), space, or comment
          n.push(c[i].substring(0, j));//add the new token
          c[i]=c[i].substring(j);//don't re-parse it!
        }
      if(n.length&&n[0].toLowerCase()!='rem')//rem is ANOTHER form of comment
      {
        n[0]=n[0].toLowerCase();//commands should be lowercase
        c[i]=n;//replace the original line of code with the newfound tokens
      }
      else//original line of code was empty or a comment, just get rid of it
        c.splice(i--, 1);
    }
    for(var i=0; i<c.length; i++)//time to find procedures!
      if(c[i][0]=='proc')//hey we found one
      {
        c[i][1]=c[i][1].toLowerCase();//all proc names will be lowercase for easier parsing
        for(var v of p)//go through existing procedures
          if(v[0][1]==c[i][1])//if we find one with the same name as ours
            throw "Duplicate proc!";
        p.push(c.splice(i, endEx(c, i)-i));//push the procedure since it's new
        c.splice(i--, 1);//and don't re-parse it later!
      }
    for(var i=0; i<p.length; i++)//go through all procedures
    {
      for(var j=2; j<p[i][0].length; j++)//then go through their parameters
      {
        p[i][0][j]=p[i][0][j].toUpperCase();//convert them to uppercase for easier comparing
        for(var k=2; k<j; k++)//go through every parameter before ours
          if(p[i][0][j]==p[i][0][k])//if it's duplicate, this is invalid!
            throw "Duplicate parameter names!";
      }
      if(p[i][0].length>2)//if there are any parameters
        procInsert(p, ['call', p[i][0][1], ...(p[i][0].slice(2).join("A ")+"A").split(" ")]);
        //then tack the letter "A" onto them to reduce the risk of proc parameter names
        //and register names clashing :)
    }
    for(var i=0; i<p.length; i++)//go through the procedures AGAIN (ugh...)
    {
      var b=true, k;//assume there's stuff to simplify
      while(b)//while there's stuff to simplify
      {
        b=false;
        for(var j=1; j<p[i].length; j++)//go through this proc's code
          if(p[i][0][1]==p[i][j][1]||p[i][j][0]=='var')//variables cannot be defined inside of procedures!
            throw "Bad proc!";
          else if(p[i][j][0]=='call')//uh oh, time to simplify!
          {
            k=procInsert(p, p[i][j]);//all "calls" are replaced with the actual proc code
            p[i].splice(j--, 1, ...p[k].slice(1));//so put that code in place of the call!
            b=true;//we did something, we better loop again later!
          }
      }
    }
  }
  for(var i=0; i<c.length; i++)//go through every line of code
  {
    if(c[i][0]=='msg')
    {
      var ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      //these are re-occuring themes in this project. In BF, the only valid commands ARE:
      //[]<>+-., so to get from register to register, we move the pointer to that register
      //do whatever we're gonna do to it, and then go back to the beginning so finding
      //another register later is easier.
      for(var j=1; j<c[i].length; j++)//go through all tokens
        if(c[i][j][0]=='"')//literal string found
        {
          r+=rl;//whenever we want a register we can completely screw around with, we go past
          //all existing registers, so ll and rl help us navigate to and from the end of regs
          for(var k=1, l=c[i][j].length-1; k<l; k++)//go through the literal text
          {
            r+="[-]";//zero out the dummy register
            if(c[i][j][k]=='\\'&&c[i][j][k+1]=='n')//newline found, it must be parsed specially
            {
              r+="++++++++++";// \n has charcode 10
              k++;//don't reparse the "n" in "\n"!
            }
            else
              r+="+".repeat(c[i][j].charCodeAt(k));//there are better ways to get to an arbitrary
              //number, but repeating "+" is the least tedious for a programmer
            r+='.';//output the current character
          }
          r+=ll;//go back to the beginning of registers
        }
        else//thing to print is a register
        {
          var a=reg.indexOf(c[i][j].toUpperCase());//find the index of the register in regs
          r+=">".repeat(a)+"."+"<".repeat(a);//go to it, print its value and restore the pointer to 0
        }
    }
    else if(c[i][0]=='var')//time to define new variables! :)
      for(var j=1; j<c[i].length; j++)//go through each var to define
      {
        c[i][j]=c[i][j].toUpperCase().split("[");//if it's a list, such as a[10], we want
        //a and 10 to be separated (we discard the extra "]" later)
        if(reg.includes(c[i][j][0])||!isNaN(c[i][j][0]))//no redefining variables or making
        //variables that are actually numbers!
          throw "Bad var name!";
        if(c[i][j].length==1)//not a list
          reg.push(c[i][j][0]);//simple!
        else//oh no a list ugh...
          if(c[i][j][1].indexOf("]")>0)//valid list
            for(var k=+c[i][j][1].split("]")[0]+4; k>0; k--)//lists are special: when we make
            //a list, we actually NEED four empty spots before it, hence the +4. additionally,
            //we need a space for each index of the register
              reg.push(c[i][j][0]);
          else//you forgot your ] buddy!
            throw "Unclosed [] pair!";
      }
    else if(c[i][0]=='read')//simple: read in a variable to a register
    {
      var n=reg.indexOf(c[i][1].toUpperCase());
      r+=">".repeat(n)+","+"<".repeat(n);//, is for reading input
    }
    else if(c[i][0]=='set')//set a register to a value (which might be another reg)
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase());
      var la="<".repeat(a), ra=">".repeat(a), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      r+=ra+"[-]";//zero out 1st reg so it can be set
      if(b<0)//second arg is a number or character
        r+=plusString(c[i][2])+la;
      else//second arg is a register
      {
        var lb="<".repeat(b), rb=">".repeat(b);
        r+=la+rb+"["+lb+ra+"+"+la+rl+"+"+ll+rb+"-]"+lb+rl+"["+ll+rb+"+"+lb+rl+"-]"+ll;
      }
    }
    else if(c[i][0]=='inc')//increment a register by a number or character
    {
      var n=reg.indexOf(c[i][1].toUpperCase());
      r+=">".repeat(n)+plusString(c[i][2])+"<".repeat(n);
    }
    else if(c[i][0]=='dec')//same as inc
    {
      var n=reg.indexOf(c[i][1].toUpperCase());
      r+=">".repeat(n)+plusString(c[i][2], '-')+"<".repeat(n);
    }
    else if(c[i][0]=='add')//add two registers or numbers and put them in another register
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), d=reg.indexOf(c[i][3].toUpperCase());
      //we call registers a, b and d because "c" is the code
      var ld="<".repeat(d), rd=">".repeat(d), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      r+=rl+"[-]"+ll;
      if(a<0)
        r+=rl+plusString(c[i][1])+ll;
      else
      {
        var la="<".repeat(a), ra=">".repeat(a);
        r+=ra+"["+la+rl+"+>+<"+ll+ra+"-]"+la+rl+">[<"+ll+ra+"+"+la+rl+">-]<"+ll;
      }
      if(b<0)
        r+=rl+plusString(c[i][2])+ll;
      else
      {
        var lb="<".repeat(b), rb=">".repeat(b);
        r+=rb+"["+lb+rl+"+>+<"+ll+rb+"-]"+lb+rl+">[<"+ll+rb+"+"+lb+rl+">-]<"+ll;
      }
      r+=rd+"[-]"+ld+rl+"["+ll+rd+"+"+ld+rl+"-]"+ll;
    }
    else if(c[i][0]=='sub')//subtract one reg from another, will eventually add number support
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), d=reg.indexOf(c[i][3].toUpperCase());
      var la="<".repeat(a), ra=">".repeat(a), lb="<".repeat(b), rb=">".repeat(b), lc="<".repeat(d), rc=">".repeat(d), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      r+=rl+"[-]>[-]<"+ll+ra+"["+la+rl+"+>+<"+ll+ra+"-]"+la+rl+"["+ll+ra+"+"+la+rl+"-]"+ll;
      r+=rb+"["+lb+rl+"+>-<"+ll+rb+"-]"+lb+rl+"["+ll+rb+"+"+lb+rl+"-]";
      r+=ll+rc+"[-]"+lc+rl+">[<"+ll+rc+"+"+lc+rl+">-]<"+ll;
    }
    else if(c[i][0]=='mul')//multiply two registers, 5*6=5+5+5+5+5+5, so we use add concept in a loop
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), d=reg.indexOf(c[i][3].toUpperCase());
      var la="<".repeat(a), ra=">".repeat(a), lb="<".repeat(b), rb=">".repeat(b), lc="<".repeat(d), rc=">".repeat(d), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      r+=rl+"[-]>[-]>[-]<<"+ll+ra+"["+la+rl+">>+<+<"+ll+ra+"-]"+la+rl+">[<"+ll+ra+"+"+la+rl+">-]>[<<"+ll;
      r+=rb+"["+lb+rl+"+>+<"+ll+rb+"-]"+lb+rl+"["+ll+rb+"+"+lb+rl+"-]>>-]<<";
      r+=ll+rc+"[-]"+lc+rl+">[<"+ll+rc+"+"+lc+rl+">-]<"+ll;
    }
    else if(c[i][0]=='divmod')//simultaneously computes div and mod of two regs and stores them in 2 regs
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), d=reg.indexOf(c[i][3].toUpperCase()), m=reg.indexOf(c[i][4].toUpperCase());
      var ld="<".repeat(d), rd=">".repeat(d), lm="<".repeat(m), rm=">".repeat(m), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      r+=rl+"[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]<<<<<<<"+ll;//we need lots of empty temporary registers for convenience
      if(a<0)//registers can be numbers, must be stored in regs though
      {
        a=plusString(c[i][1]);
        r+=rl+">>>"+a+"<<<"+ll;
      }
      else
      {
        var la="<".repeat(a), ra=">".repeat(a);
        r+=ra+"["+la+rl+"+>>>+<<<"+ll+ra+"-]"+la+rl+"["+ll+ra+"+"+la+rl+"-]"+ll;
      }
      if(b<0)
      {
        b=plusString(c[i][2]);
        r+=rl+">"+b+">>>"+b+"<<<";
      }
      else
      {
        var lb="<".repeat(b), rb=">".repeat(b);
        r+=rb+"["+lb+rl+"+>+>>>+<<<<"+ll+rb+"-]"+lb+rl+">[<"+ll+rb+"+"+lb+rl+">-]";
      }//the actual divmod algorithm is below
      r+="+<-[>>>[->-[>+>>]>[+[-<+>]>+>>]<<<<<]<<-<[-]]>[>>[>>>+<<<-]<<-]<";
      r+=ll+rd+"[-]"+ld+rm+"[-]"+lm+rl+">>>>>>[<<<<<<"+ll+rd+"+"+ld+rl+">>>>>>-]<[<<<<<"+ll+rm+"+"+lm+rl+">>>>>-]<<<<<"+ll;
    }
    else if(c[i][0]=='div')//same as divmod, but just put mod somewhere we don't care about
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), d=reg.indexOf(c[i][3].toUpperCase()), m=reg.length;
      var ld="<".repeat(d), rd=">".repeat(d), lm="<".repeat(m), rm=">".repeat(m), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      r+=rl+"[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]<<<<<<<"+ll
      if(a<0)
      {
        a=plusString(c[i][1]);
        r+=rl+">>>"+a+"<<<"+ll;
      }
      else
      {
        var la="<".repeat(a), ra=">".repeat(a);
        r+=ra+"["+la+rl+"+>>>+<<<"+ll+ra+"-]"+la+rl+"["+ll+ra+"+"+la+rl+"-]"+ll;
      }
      if(b<0)
      {
        b=plusString(c[i][2]);
        r+=rl+">"+b+">>>"+b+"<<<";
      }
      else
      {
        var lb="<".repeat(b), rb=">".repeat(b);
        r+=rb+"["+lb+rl+"+>+>>>+<<<<"+ll+rb+"-]"+lb+rl+">[<"+ll+rb+"+"+lb+rl+">-]";
      }//same algo from divmod
      r+="+<-[>>>[->-[>+>>]>[+[-<+>]>+>>]<<<<<]<<-<[-]]>[>>[>>>+<<<-]<<-]<";
      r+=ll+rd+"[-]"+ld+rm+"[-]"+lm+rl+">>>>>>[<<<<<<"+ll+rd+"+"+ld+rl+">>>>>>-]<[<<<<<"+ll+rm+"+"+lm+rl+">>>>>-]<<<<<"+ll;
    }
    else if(c[i][0]=='mod')//same as divmod
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), d=reg.length, m=reg.indexOf(c[i][3].toUpperCase());
      var ld="<".repeat(d), rd=">".repeat(d), lm="<".repeat(m), rm=">".repeat(m), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      r+=rl+"[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]<<<<<<<"+ll
      if(a<0)
      {
        a=plusString(c[i][1]);
        r+=rl+">>>"+a+"<<<"+ll;
      }
      else
      {
        var la="<".repeat(a), ra=">".repeat(a);
        r+=ra+"["+la+rl+"+>>>+<<<"+ll+ra+"-]"+la+rl+"["+ll+ra+"+"+la+rl+"-]"+ll;
      }
      if(b<0)
      {
        b=plusString(c[i][2]);
        r+=rl+">"+b+">>>"+b+"<<<";
      }
      else
      {
        var lb="<".repeat(b), rb=">".repeat(b);
        r+=rb+"["+lb+rl+"+>+>>>+<<<<"+ll+rb+"-]"+lb+rl+">[<"+ll+rb+"+"+lb+rl+">-]";
      }
      r+="+<-[>>>[->-[>+>>]>[+[-<+>]>+>>]<<<<<]<<-<[-]]>[>>[>>>+<<<-]<<-]<";
      r+=ll+rd+"[-]"+ld+rm+"[-]"+lm+rl+">>>>>>[<<<<<<"+ll+rd+"+"+ld+rl+">>>>>>-]<[<<<<<"+ll+rm+"+"+lm+rl+">>>>>-]<<<<<"+ll;
    }
    else if(c[i][0]=='cmp')//compare two regs, number or characters
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), d=reg.indexOf(c[i][3].toUpperCase());
      var ll="<".repeat(reg.length), rl=">".repeat(reg.length), ld="<".repeat(d), rd=">".repeat(d);
      r+=rl+"[-]>[-]>[-]>[-]>[-]>[-]>[-]<<<<<<"+ll;
      if(a<0)
      {
        a=plusString(c[i][1]);
        r+=rl+">>>"+a+">>"+a+"<<<<<"+ll;
      }
      else
      {
        var la="<".repeat(a), ra=">".repeat(a);
        r+=ra+"["+la+rl+"+>>>+>>+<<<<<"+ll+ra+"-]"+la+rl+"["+ll+ra+"+"+la+rl+"-]"+ll;
      }
      if(b<0)
      {
        b=plusString(c[i][2]);
        r+=rl+">>>>"+b+">>"+b+"<<<<<<"+ll;
      }
      else
      {
        var lb="<".repeat(b), rb=">".repeat(b);
        r+=rb+"["+lb+rl+"+>>>>+>>+<<<<<<"+ll+rb+"-]"+lb+rl+"["+ll+rb+"+"+lb+rl+"-]"+ll;
      }//for cmp a b c, c will be 255 if a<b, 0 if a==b and 1 if a>b
      r+=rl+">>>[<<<+>>>>[-<<<<[-]>+>>>]<<<<[->>+<<]>[->>>+<<<]>>>-<-]";
      r+=">>[->-<]+>[<->[-]]<<<<<<"+ll+rd+"[-]-"+ld+rl+">>[<<"+ll+rd+"++"+ld+rl+">>-]>>>[<<<<<";
      r+=ll+rd+"+"+ld+rl+">>>>>-]<<<<<"+ll;
    }
    else if(c[i][0]=='a2b')//treats three registers as ascii digits and converts them to binary
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), o=reg.indexOf(c[i][3].toUpperCase()), d=reg.indexOf(c[i][4].toUpperCase());
      var la="<".repeat(a), ra=">".repeat(a), lb="<".repeat(b), rb=">".repeat(b), ld="<".repeat(d), rd=">".repeat(d), lo="<".repeat(o), ro=">".repeat(o), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      var m='-'.repeat(48);
      r+=rl+"[-]>[-]>[-]<<"+ll+ro+"["+lo+rl+"+>+<"+ll+ro+"-]"+lo+rl+m+">[<"+ll+ro+"+"+lo+rl+">-]<"+ll;
      r+=ra+"["+la+rl+">+>+<<"+ll+ra+"-]"+la+rl+">>[<<"+ll+ra+"+"+la+rl+">>-]<"+m+"[<"+"+".repeat(100)+">-]<"+ll;
      r+=rb+"["+lb+rl+">+>+<<"+ll+rb+"-]"+lb+rl+">>[<<"+ll+rb+"+"+lb+rl+">>-]<"+m+"[<++++++++++>-]<"+ll;
      r+=rd+"[-]"+ld+rl+"["+ll+rd+"+"+ld+rl+"-]"+ll;
    }
    else if(c[i][0]=='b2a')//takes one character and converts it's charCode to an ascii number
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), h=reg.indexOf(c[i][2].toUpperCase()), t=reg.indexOf(c[i][3].toUpperCase()), o=reg.indexOf(c[i][4].toUpperCase());
      if(reg[a]==reg[a+1]||reg[h]==reg[h+1]||reg[t]==reg[t+1]||reg[o]==reg[o+1])
      //if ANY registers are lists
        throw "Lists are not vars!";
      var la="<".repeat(a), ra=">".repeat(a), lh="<".repeat(h), rh=">".repeat(h), lt="<".repeat(t), rt=">".repeat(t), lo="<".repeat(o), ro=">".repeat(o), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      var pl="+".repeat(48);
      r+=rl+"[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]>[-]<<<<<<<<"+pl+ll+ra+"["+la+rl+">+>+<<"+ll+ra+"-]"+la+rl+">>[<<"+ll+ra+"+"+la+rl;
      r+=">>-]>++++++++++<<[->+>-[>+>>]>[+[-<+>]>+>>]<<<<<<]>>>[<<<<+>>>>-]<<<<"+ll+ro+"[-]"+lo+rl+"["+ll+ro+"+"+lo+rl+"-]";
      r+=">>[-]++++++++++>[-]>[-]>[<<<<<+>>>>>-]<<<<<[->+>-[>+>>]>[+[-<+>]>+>>]<<<<<<]"+ll+rt+"[-]"+lt;
      r+=rl+">>>"+pl+"[<<<"+ll+rt+"+"+lt+rl+">>>-]>"+pl+"<<<<"+ll+rh+"[-]"+lh+rl+">>>>[<<<<"+ll+rh+"+"+lh+rl+">>>>-]<<<<"+ll;
    }
    else if(c[i][0]=='lset')//lset a i n does a[i]=n, throws error if arguments are not correct types
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), x=reg.indexOf(c[i][3].toUpperCase());
      var la="<".repeat(a), ra=">".repeat(a);
      if(reg[a]!=reg[a+1])
        throw "Expected a list but got a variable!";
      if(b<0)
      {
        b=plusString(c[i][2]);
        r+=ra+">"+b+">"+b+"<<"+la;
      }
      else
      {
        var lb="<".repeat(b), rb=">".repeat(b);
        r+=rb+"["+lb+ra+"+>+>+<<"+la+rb+"-]"+lb+ra+"["+la+rb+"+"+lb+ra+"-]"+la;
      }
      if(x<0)
        r+=ra+">>>"+plusString(c[i][3])+"<<<"+la;
      else
      {
        if(reg[x]==reg[x+1])
          throw "Expected a variable but got a list!";
        var lx="<".repeat(x), rx=">".repeat(x);
        r+=rx+"["+lx+ra+"+>>>+<<<"+la+rx+"-]"+lx+ra+"["+la+rx+"+"+lx+ra+"-]"+la;
      }
      r+=ra+">[>>>[-<<<<+>>>>]<[->+<]<[->+<]<[->+<]>-]>>>[-]<[->+<]<[[-<+>]<<<[->>>>+<<<<]>>-]<<"+la;
    }
    else if(c[i][0]=='lget')//same as lset, except it's n=a[i]
    {
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), x=reg.indexOf(c[i][3].toUpperCase());
      var la="<".repeat(a), ra=">".repeat(a), lx="<".repeat(x), rx=">".repeat(x);
      if(reg[a]!=reg[a+1])//lists have all their indeces named the same, so these should equal
        throw "Expected a list but got a variable!";
      if(b<0)
      {
        b=plusString(c[i][2]);
        r+=ra+">"+b+">"+b+"<<"+la;
      }
      else
      {
        var lb="<".repeat(b), rb=">".repeat(b);
        r+=rb+"["+lb+ra+"+>+>+<<"+la+rb+"-]"+lb+ra+"["+la+rb+"+"+lb+ra+"-]"+la;
      }
      r+=rx+"[-]"+lx+ra+">[>>>[-<<<<+>>>>]<<[->+<]<[->+<]>-]>>>[-<+<<+>>>]<<<[->>>+<<<]>[[-<+>]>[-<+>]<<<<[->>>>+<<<<]>>-]>[<<<"
      r+=la+rx+"+"+lx+ra+">>>-]<<<"+la;
    }
    else if(c[i][0]=='wneq')//while not equals, easier than while equals because of BF
    {//first arg is assumed to be a register, second should be a number
      var m=plusString(c[i][2], '-'), pl=plusString(c[i][2]), a=reg.indexOf(c[i][1].toUpperCase());
      var la="<".repeat(a), ra=">".repeat(a), j=endEx(c, i);
      r+=ra+m+"["+pl+la+kcuf(c.slice(i+1, j), reg, p, true)+ra+m+"]"+pl+la;
      i=j;
    }
    else if(c[i][0]=='ifneq')//similar to wneq, except we zero out the value we check so loop terminates
    {//after a single iteration
      var a=reg.indexOf(c[i][1].toUpperCase()), b=reg.indexOf(c[i][2].toUpperCase()), j=endEx(c, i);
      var la="<".repeat(a), ra=">".repeat(a), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      r+=rl+"[-]>[-]<"+ll+ra+"["+la+rl+"+>+<"+ll+ra+"-]"+la+rl+">[<"+ll+ra+"+"+la+rl+">-]<";
      if(b<0)
        r+=plusString(c[i][2], '-');
      else
      {
        var lb="<".repeat(b), rb=">".repeat(b);
        r+=ll+rb+"["+lb+rl+"->+<"+ll+rb+"-]"+lb+rl+">[<"+ll+rb+"+"+lb+rl+">-]<";
      }
      r+="["+ll+kcuf(c.slice(i+1, j), reg, p, true)+rl+"[-]]"+ll;
      i=j;
    }
    else if(c[i][0]=='ifeq')//similar to ifneq, except we have a flag to determine whether
    {//ifneq was true or not so we know whether to run ifeq code
      var a=reg.indexOf(c[i][1].toUpperCase()), j=endEx(c, i), m=plusString(c[i][2], '-');
      var la="<".repeat(a), ra=">".repeat(a), ll="<".repeat(reg.length), rl=">".repeat(reg.length);
      r+=rl+"[-]>[-]<"+ll+ra+"["+la+rl+"+>+<"+ll+ra+"-]"+la+rl+">[<"+ll+ra+"+"+la+rl+">-]+<";
      r+=m+"[>-<[-]]>[<"+ll+kcuf(c.slice(i+1, j), reg, p, true)+rl+">[-]]<"+ll;
      i=j;
    }
    else if(c[i][0]=='call')//replace calls with their actual code
    {
      var k=procInsert(p, c[i]), t=[];
      for(var j=1; j<p[k].length; j++)
        t.push(p[k][j].slice());//manually insert all the new code where call was
      r+=kcuf(t, reg, p, true);//similar to wneq, ifneq and ifeq, recursively evaluate inner code
    }
    else//will only get here if instruction could not be processed
      throw "Unknown instruction!";
  }
  return r;
}
/**
 * Given a value, v, return a number of plus signs based on the character code for letters OR the number provided
 * @param v The value to use
 * @param s The sign to repeat, "+" by default
 */
function plusString(v, s="+")
{
  if(isNaN(v))//not a number
    if(v.length==3)//we assume it's a character in single quotes, like 'a' or 'Z'
      return s.repeat(v.charCodeAt(1));//1 is middle character, which is the one that matters
    else//must be length 3 to be in above format
      throw "Unclosed '' pair!";
  v=+v;//v always starts as a String, but we know it's a number so convert it to one!
  while(v<0)//if they give us a negative value
    v+=256;//wrap it into the range [0, 255]
  return s.repeat(v%256);//could've given us huge number, modulate to put it in correct range for BF
}
/**
 * Given code and an index to start at, find the corresponding "end" command for a command
 * such as wneq, ifneq or ifeq
 * @param c The code to parse
 * @param i The index to begin parsing at
 */
function endEx(c, i)
{
  var n=1;//we know we need to find one end
  for(i++; n>0; i++)//while we haven't grouped every ifeq or whatever with an 'end'
    if(c[i][0]=='wneq'||c[i][0]=='ifneq'||c[i][0]=='ifeq')//uh oh, better find more ends!
      n++;
    else if(c[i][0]=='end')
      n--;
  return i-1;//always goes one past the 'end' we want, subtract one to account for this
}
/**
 * Given a procedure and a line of code calling that procedure, replace all variables
 * used in the procedure to match those in the call statement so the procedure code
 * can be directly injected into the original code
 * @param p The procedures to pull from
 * @param c The line of code to base paramater names off of
 */
function procInsert(p, c)
{
  c[1]=c[1].toLowerCase();//this makes finding the correct procedure easier
  for(var i=0; i<p.length; i++)//go through all procedures
    if(p[i][0][1]==c[1])//if we found the right procedure
    {
      if(p[i][0].length!=c.length)//make sure we have enough parameters to call it!
        throw "Proc parameter mismatch!";
      for(var j=2; j<c.length; j++)//go through all parameters
      {
        c[j]=c[j].toUpperCase();//makes finding parameters easier
        for(var k=1; k<p[i].length; k++)//go through every line of the procedure
          for(var l=1; l<p[i][k].length; l++)//and every POSSIBLE instance of the reg to replace
            if(p[i][0][j]==p[i][k][l].toString().toUpperCase())//sometimes numbers sneak their way into procedures... Don't ask me how!
              p[i][k][l]=c[j];//replace the register name
      }
      for(var j=2; j<c.length; j++)//go through the first line of the procedure
        p[i][0][j]=c[j];//and replace its arguments since they're now irrelevant
      return i;//returns the index of the correct procedure in the procedure list
    }
}
NOPRINT = true//Set this to false if you want code to print on codewars
9 hours agoRefactorDiscuss
1 kyu
Functional SQL
JavaScript:
var query = function() {
	var self = {};
	
	var tables = [];
	var selector = null;

	var whereClauses = [];
	var havingClauses = [];
	
	var order = [];
	var group = [];
	
	var selectorAll = function(row) {
		return row;
	};
	
	self.select = function(e) {
		if (selector != null) throw new Error('Duplicate SELECT');
		selector = e || false; 
		return self; 
	};
	
	self.from = function() {
		if (tables.length > 0) throw new Error('Duplicate FROM');
		tables = Array.from(arguments);
		return self;
	};
	
	self.where = function() {
		whereClauses.push( Array.from(arguments) );
		return self;
	};
	
	self.having = function() {
		havingClauses.push( Array.from(arguments) );
		return self;
	};
	
	self.orderBy = function() {
		if (order.length > 0) throw new Error('Duplicate ORDERBY');
		order = Array.from(arguments);
		return self;
	};
	
	self.groupBy = function() {
		if (group.length > 0) throw new Error('Duplicate GROUPBY');
		group = Array.from(arguments);
		return self;
	};
	
	self.execute = function() {		
		var tmpdata = [];
		var gdata = [];

		var data = [];
		var t = 0;

		// JOIN

		if (tables.length > 1) {

			tables.forEach(function() {
        			data.push([ ]);
     			});

			tables[0].forEach(function(row, i) {
				for (t = 0; t < tables.length; t++) {
					data[t].push( tables[t][i] );
				}
			});

			tmpdata = [];
			(function traverseTable(D, t) {
				if (D.length === 0) {
					tmpdata.push( t.slice(0) );
				} else {
					for (var i = 0; i < D[0].length; i++) {
						t.push( D[0][i] );
						traverseTable( D.slice(1), t );
						t.splice(-1, 1);
					}
				}
			})(data, []);

			data = [];
			tmpdata.forEach(function(row, i) {
				if (whereClauses.every(function(orWhereClauses) {
					return orWhereClauses.some(function(whereClause) {
						return whereClause( row );
					});
				})) {
					data.push( row );
				}
			});

		} else if (tables.length === 1) {

			tables[0].forEach(function(row, i) {
				if (whereClauses.every(function(orWhereClauses) {
					return orWhereClauses.some(function(whereClause) {
						return whereClause( row );
					});
				})) {
					data.push( row );
				}
			});

		} else {
			data = [];
		}

		// Group

		if (group.length > 0) {

			var T = {};

			data.forEach(function(row) {
				var t = T;
				group.forEach(function(groupCallback) {
					var k = groupCallback(row);
					t[k] = t[k] || {}; t = t[k];
				});
				t._data = t._data || []; t._data.push(row);
			});

			(function traverse(node, R) {
				if (node._data != null) {
					node._data.forEach(function(e) { R.push(e); });
				} else {
					for (var k in node) {
						k = /\d+/.test(k) ? Number(k) : k;
						var row = [ k, [] ];
						traverse(node[k], row[1]);
						R.push(row);
					}
				}
			})(T, gdata);

			gdata.forEach(function(grow){ 
				if (havingClauses.every(function(orHavingClauses) {
					return orHavingClauses.some(function(havingClause) {
						return havingClause(grow);
					});
				})) {
					tmpdata.push(grow);
				}
			});
			data = tmpdata;

		}

		order.forEach(function(orderCallback) {
			data = data.sort(orderCallback);
		});
		
		return data.map( selector || selectorAll );
	};

	return self;
};
6 days agoRefactorDiscuss
3 kyu
Calculator
Python:
class Calculator(object):
  def evaluate(self, string):
    #Will replace all spaces with nothing, no n such that n > 9 OR n < 0
    stack = []
    expr_ini = 0
    OPERATOR = '+'
    i = 0
    while i < len(string):
        if string[i] == ' ':
            i += 1
        elif string[i].isdigit():
            expr_ini = i
            expr_end = i
            while expr_end < len(string) and (string[expr_end].isdigit() or string[expr_end] == '.'):
                expr_end += 1
            temp = float(string[expr_ini : expr_end])
            if OPERATOR == '+':
                stack.append(temp)
            elif OPERATOR == '-':
                stack.append(-1 * temp)
            elif OPERATOR == '*':
                prev = stack.pop()
                stack.append(prev * temp)
            else:
                prev = stack.pop()
                stack.append(prev / temp)
            i = expr_end + 1
        else:
            OPERATOR = string[i]
            i += 1
    return round(sum(stack), 3)
6 days agoRefactorDiscuss
4 kyu
The observed PIN
Ruby:
DIGITS = {
  1=>[1,2,4]  ,2=>[1,2,3,5]  ,3=>[2,3,6],
  4=>[1,4,5,7],5=>[2,4,5,6,8],6=>[3,5,6,9],
  7=>[4,7,8]  ,8=>[0,5,7,8,9],9=>[6,8,9],
               0=>[0,8]
}

# Convert to strings
# - If you're using an older version of Ruby, you can comment this out and use
#     observed[...].to_i() in get_pins() instead.
DIGITS.transform_keys!(&:to_s)              # Ruby v2.5+
DIGITS.transform_values!{|v| v.map(&:to_s)} # Ruby v2.4+

def get_pins(observed)
  result = []
  
  DIGITS[observed[0]].each do |digit|
    pins = [[digit]] # Double array for length of 1
    
    for i in 1...observed.length
      pins = pins.product(DIGITS[observed[i]])
    end
    
    pins.map!{|pin| pin.flatten.join}
    result.push(pins)
  end
  
  result.flatten!
  result
end

# [0, 5, 7, 8, 9]
puts get_pins('8').sort.map(&:to_i).inspect
# [11, 12, 14, 21, 22, 24, 41, 42, 44]
puts get_pins('11').sort.map(&:to_i).inspect
# [236, 238, 239, 256, 258, 259, 266, 268, 269, 296, 298, 299, 336, 338, 339,
#  356, 358, 359, 366, 368, 369, 396, 398, 399, 636, 638, 639, 656, 658, 659,
#  666, 668, 669, 696, 698, 699]
puts get_pins('369').sort.map(&:to_i).inspect

#puts get_pins('2458').inspect
#puts get_pins('14290').inspect
#puts get_pins('683102).inspect

puts unless ARGV.empty?
ARGV.each do |arg|
  puts "#{arg} => #{get_pins(arg).sort.map(&:to_i).inspect}"
end
6 days agoRefactorDiscuss
4 kyu
Ten-Pin Bowling
Ruby:
def bowling_score(frames)
  factors = [1,1,1] # For spares & strikes
  prev_strike = false
  
  frames.split(/\s+/).reduce(0) do |score,frame|
    spare,strike = frame[1] == '/',frame[0] == 'X'
    
    prev_roll = 0
    rolls = frame.chars.map do |f|
      prev_roll = (f == '/') ? (10 - prev_roll) :
                  (f == 'X') ? 10 : f.to_i
    end
    rolls = rolls.zip(factors).map{|r,f| r * f}.reduce(&:+)
    
    factors = [spare  ? 2 :
               strike ? (prev_strike ? [factors[0] + 1,3].min : 2) : 1,
               strike ? 2 : 1,1]
    
    prev_strike = strike
    score + rolls
  end
end

puts bowling_score('11 11 11 11 11 11 11 11 11 11') # 20
puts bowling_score('X X X X X X X X X XXX')         # 300
puts bowling_score('5/ 4/ 3/ 2/ 1/ 0/ X 9/ 4/ 8/8') # 150
puts bowling_score('18 9/ X 70 08 9/ 50 12 81 XXX') # 123
puts bowling_score('5/ 4/ 3/ 2/ 1/ 0/ X 9/ 4/ 8/X') # 152
puts bowling_score('5/ 4/ 3/ 2/ 1/ 0/ X 9/ 4/ X8/') # 154

ARGV.each do |arg|
  puts "#{bowling_score(arg)}: #{arg}"
end
6 days agoRefactorDiscuss
4 kyu
Pyramid Slide Down
Ruby:
def longest_slide_down(pyramid,y=pyramid.length - 1,bottom=[Slide.new])
  if y == 0
    bottom[0].cost += pyramid[0][0]
    
    # Show the pyramid and the longest slide down as dots
    child = Slide.new(0,bottom[0],0,0)
    until (child = child.child).nil?
      print (' ' * ((pyramid.length - 1 - child.y) * 2))
      pyramid[child.y].each_with_index{|c,x| print (x == child.x) ? ' . ' : ('%3d ' % [c])}
      puts
    end
    puts "Longest slide down: #{bottom[0].cost}"
    
    return bottom[0].cost
  end
  
  row_len = pyramid[y].length
  
  # Can't use *= because we need new objects (not all the same reference)
  bottom = Array.new(row_len){|x| Slide.new(0,nil,x,y)} if bottom.length == 1
  bottom.map!.with_index{|slide,x| slide.cost += pyramid[y][x]; slide}
  
  row = []
  y -= 1
  
  for x in 0..row_len - 2
    child = bottom[x..x + 1].max
    row.push(Slide.new(child.cost,child,x,y))
  end
  
  longest_slide_down(pyramid,y,row)
end

class Slide
  attr_accessor :child,:cost,:x,:y
  
  def initialize(cost=0,child=nil,x=0,y=0)
    @child = child
    @cost = cost
    @x = x
    @y = y
  end
  
  # Needed for [].max()
  def <=>(other)
    @cost <=> other.cost
  end
end

# 23
longest_slide_down([
      [3],
     [7, 4],
   [2, 4, 6],
  [8, 5, 9, 3]
])
puts

# 1074
longest_slide_down([
                              [75],
                            [95, 64],
                          [17, 47, 82],
                        [18, 35, 87, 10],
                      [20,  4, 82, 47, 65],
                    [19,  1, 23, 75,  3, 34],
                  [88,  2, 77, 73,  7, 63, 67],
                [99, 65,  4, 28,  6, 16, 70, 92],
              [41, 41, 26, 56, 83, 40, 80, 70, 33],
            [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
          [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
        [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
      [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
    [63, 66,  4, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
  [ 4, 62, 98, 27, 23,  9, 70, 98, 73, 93, 38, 53, 60,  4, 23]
])
6 days agoRefactorDiscuss
4 kyu
Catching Car Mileage Numbers
Ruby:
def is_interesting(num,awesome_phrases,score=2)
  return score if awesome_phrases.include?(num)
  
  # No num.to_s.length added challenge :)
  len,n = 1,num
  while (n /= 10) > 0
    len += 1
  end
  
  if len >= 3
    return score if is_zeros(num,len)              # 100, 90000
    return score if is_same_or_palindrome(num,len) # 1111, 1221, 73837
    return score if is_seq_inc_or_dec(num,len)     # 1234, 4321
  end
  
  return 0 if score == 1
  return score if (score = is_interesting(num + 1,awesome_phrases,1)) > 0
  return is_interesting(num + 2,awesome_phrases,1)
end

def is_zeros(num,len)
  tens = 10 ** (len - 1)
  (num / tens) == (num.to_f / tens)
end

def is_same_or_palindrome(num,len)
  half_len = len / 2.0
  half1 = num / (10 ** half_len.round)
  
  half_len = half_len.to_i
  half2 = 0
  for i in 1..half_len
    n = num % (10 ** i)         # shift digits left
    n /= (10 ** (i - 1))        # current digit
    n *= (10 ** (half_len - i)) # reverse pos (places)
    half2 += n
  end
  
  half1 == half2
end

def is_seq_inc_or_dec(num,len)
  prev_digit = num / (10 ** (len - 1)) # first digit
  is_inc,is_dec = true,true
  
  while (len -= 1) >= 1
    digit = num % (10 ** len)  # shift digits left
    digit /= (10 ** (len - 1)) # current digit
    
    is_inc = false if digit != inc_or_dec(prev_digit,1)
    is_dec = false if digit != inc_or_dec(prev_digit,-1)
    return false unless is_inc || is_dec
    
    prev_digit = digit
  end
  
  is_inc || is_dec
end

def inc_or_dec(num,inc_or_dec)
  num += inc_or_dec
  (num < 0) ? 9 : ((num > 9) ? 0 : num)
end

puts is_interesting(3,[1337,256])     # 0
puts is_interesting(1336,[1337,256])  # 1
puts is_interesting(1337,[1337,256])  # 2
puts is_interesting(11208,[1337,256]) # 0
puts is_interesting(11209,[1337,256]) # 1
puts is_interesting(11211,[1337,256]) # 2
puts is_interesting(90000,[1337,256]) # 2
puts is_interesting(99999,[1337,256]) # 2
puts is_interesting(12821,[1337,256]) # 2
puts is_interesting(10801,[1337,256]) # 2
puts is_interesting(12345,[1337,256]) # 2
puts is_interesting(54321,[1337,256]) # 2

puts unless ARGV.empty?
ARGV.each do |arg|
  puts "#{arg} => #{is_interesting(arg.to_i,[1337,256,1987,2012,42])}"
end
6 days agoRefactorDiscuss
4 kyu
Snail
Java:
import java.util.Arrays;

public class Snail {
  public static final int WALL = -1;
  
  public static void main(String[] args) {
    // {1,2,3,6,9,8,7,4,5}
    System.out.println(Arrays.toString(snail(new int[][]{{1,2,3},{4,5,6},{7,8,9}})));
  }
  
  public static int[] snail(int[][] array) {
    if(array[0].length <= 0) { return new int[0]; }
    
    int n = array.length;
    int[] result = new int[n * n];
    int x = 0,y = 0;
    int xStep = 1,yStep = 0;
    
    for(int i = 0; i < result.length; ++i) {
      result[i] = array[y][x];
      array[y][x] = WALL;
      
      x += xStep; y += yStep;
      
      if(xStep != 0 && (x < 0 || x >= n || array[y][x] == WALL)) {
        x += -xStep; y += xStep;
        yStep = xStep; xStep = 0;
      }
      else if(yStep != 0 && (y < 0 || y >= n || array[y][x] == WALL)) {
        x += -yStep; y += -yStep;
        xStep = -yStep; yStep = 0;
      }
    }
    
    return result;
  }
}
6 days agoRefactorDiscuss
3 kyu
Psychic
Java:
import java.lang.reflect.Field;

import java.util.Random;

import java.util.concurrent.atomic.AtomicLong;

/**
 * <pre>
 * You either had to use reflection or copy & paste the math from the source code.
 * 
 * I decided to use reflection. However, less verbose solutions were made by
 *   just setting the seed to 0.
 * 
 * I looked at the OpenJDK source code, and just hoped that it would be the same.
 * </pre>
 * 
 * @author Jonathan Bradley Whited (@esotericpig)
 * @see    https://www.codewars.com/kata/psychic/java
 * @see    https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html
 * @see    https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/Field.html
 * @see    http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/lang/Math.java
 * @see    http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/Random.java
 * @rank   3 kyu
 */
public class Psychic {
  public static void main(String[] args) {
    for(int i = 0; i < 5; ++i) {
      double guess = Psychic.guess();
      double choice = Math.random();
      
      // https://docs.oracle.com/javase/tutorial/java/data/numberformat.html
      // https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax
      System.out.format("%1.20f =? %1.20f => %b%n",guess,choice,guess == choice);
    }
  }
  
  public static double guess() {
    try {
      return (new Psychic()).predict();
    }
    // Bad way to handle errors...
    catch(Exception e) {
      System.out.println(e);
    }
    return -11.11;
  }
  
  protected Random rand;
  protected AtomicLong seed;
  
  public Psychic() throws Exception {
    rand = getMathRand();
    seed = (AtomicLong)getObjVar(rand,"seed");
  }
  
  public double predict() throws Exception {
    Random rand = new Random();
    
    setObjVar(rand,"seed",new AtomicLong(seed.get()));
    
    return rand.nextDouble();
  }
  
  public static void setObjVar(Object obj,String id,Object value) throws Exception {
    Field field = obj.getClass().getDeclaredField(id);
    
    field.setAccessible(true);
    field.set(obj,value);
  }
  
  public static Random getMathRand() throws Exception {
    Class holder = Class.forName("java.lang.Math$RandomNumberGeneratorHolder");
    Field field = holder.getDeclaredField("randomNumberGenerator");
    
    field.setAccessible(true);
    
    return (Random)field.get(holder);
  }
  
  public static Object getObjVar(Object obj,String id) throws Exception {
    Field field = obj.getClass().getDeclaredField(id);
    
    field.setAccessible(true);
    
    return field.get(obj);
  }
}
6 days agoRefactorDiscuss
3 kyu
The Lift
Python:
UP = 1
DOWN = -1

class Dinglemouse(object):
    """ The Lift solver class """

    def __init__(self, queues, capacity):
        self.queues = tuples_to_list(queues)
        self.top_floor = len(self.queues) - 1
        self.ground_floor = 0
        self.capacity = capacity
        self.passengers = []
        self.stops = []
        self.floor = 0
        self.direction = UP
        self.lift_floor = None

    def theLift(self):
        """ main function """
        while not self.floor_queues_empty() or not self.lift_is_empty():
            if self.stop_lift():
                self.passengers_leaving()
                self.passengers_entering()
            if self.floor == self.top_floor:
                self.direction = DOWN
            if self.floor == self.ground_floor:
                self.direction = UP
            if self.floor == 0 and not self.stops:
                self.stops.append(0)
            self.floor += self.direction
        if self.stops[-1:] != [0]:
            self.stops.append(0)
        return self.stops

    def floor_queues_empty(self):
        """ check if floor queues are empty """
        return is_list_empty(self.queues)

    def lift_is_empty(self):
        """ check if lift is empty """
        return False if self.passengers else True

    def stop_lift(self):
        """ check whether the lift needs to stop """
        ret = False
        to_enter = [p for p in self.queues[self.floor] if self.passenger_to_enter(p)]
        if self.floor in self.passengers or to_enter:
            ret = True
            if self.floor != self.lift_floor:
                self.stops.append(self.floor)
                self.lift_floor = self.floor
        return ret

    def passengers_leaving(self):
        """ passengers leaving the lift """
        remain = [p for p in self.passengers if p != self.floor]
        if len(remain) != len(self.passengers):
            self.passengers = remain

    def passengers_entering(self):
        """ passengers enter the lift """
        passengers = self.queues[self.floor][:]
        for passenger in passengers:
            if len(self.passengers) < self.capacity and \
               self.passenger_to_enter(passenger):
                self.passengers.append(passenger)
                self.queues[self.floor].pop(self.queues[self.floor].index(passenger))

    def passenger_to_enter(self, p):
        """ check if a passenger will enter the lift """
        return (self.direction == UP and p > self.floor) or \
               (self.direction == DOWN and p < self.floor) or \
               self.floor == self.top_floor or \
               self.floor == self.ground_floor

def tuples_to_list(i):
    """ transform nested tuples to nested lists """
    if isinstance(i, (tuple, list)):
        l = [list(e) if isinstance(e, tuple) else e for e in i]
    else:
        return i
    for i, e in enumerate(l):
        l[i] = tuples_to_list(e)
    return l

def is_list_empty(in_list):
    """ check if all elements of a nested list are empty """
    if isinstance(in_list, list):
        return all(map(is_list_empty, in_list))
    return False

if __name__ == "__main__":
    q = ((), (0,), (), (), (2,), (3,), ())
    lift = Dinglemouse(q, 5)
    lift_stops = lift.theLift()
    print(lift_stops)
6 days agoRefactorDiscuss
3 kyu
The Millionth Fibonacci Kata
Python:
def mul(mat1, mat2):
    mat3 = []
    for i in xrange(2):
        r = []
        for j in xrange(2):
            t = 0
            for k in xrange(2):
                t += mat1[i][k] * mat2[k][j]
            r.append(t)
        mat3.append(r)
    return mat3

def fib(n):
    r = [[1, 0], [0, 1]]
    t = [[0, 1], [1, 1]]
    if n < 0:
        n = -n
        t = [[-1, 1], [1, 0]]
    while n > 0:
        if (n & 1) > 0:
            r = mul(t, r)
        t = mul(t, t)
        n >>= 1
    return r[0][1]
    
6 days agoRefactorDiscuss
1 kyu
Faberge easter eggs crush test [linear]
Python:
MOD = 998244353
haha_inv = [0, 1]
for haha_i in range(2, 80000 + 1):
        haha_inv.append( (MOD - MOD // haha_i) * haha_inv[MOD % haha_i] % MOD )
def height(n, m):  
    h, t = 0, 1
    m %= MOD

    for i in range(1, n + 1): 
        t = t * (m - i + 1) * haha_inv[i] % MOD
        h = (h + t) % MOD
    return h % MOD
6 days agoRefactorDiscuss
1 kyu
BECOME IMMORTAL
Python:
def larger_pow(x):
    t = 1
    while t < x:
        t <<= 1
    return t

def range_sum(l, r):
    return (l + r) * (r - l + 1) // 2

def elder_age(m,n,l,t):
    if m == 0 or n == 0:
        return 0
    if m > n:
        m, n = n, m
    lm, ln = larger_pow(m), larger_pow(n)
    if l > ln:
        return 0

    if lm == ln:
        return (range_sum(1, ln - l - 1) * (m + n - ln) + elder_age(ln - n, lm - m, l, t)) % t
    
    if lm < ln:
        lm = ln // 2
        tmp = range_sum(1, ln - l - 1) * m - (ln - n) * range_sum(max(0, lm - l), ln - l - 1)
        if l <= lm:
            tmp += (lm - l) * (lm - m) * (ln - n) + elder_age(lm - m, ln - n, 0, t)
        else:
            tmp += elder_age(lm - m, ln - n, l - lm, t)
        return tmp % t
6 days agoRefactorDiscuss
4 kyu
4 By 4 Skyscrapers
C++:
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <map>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 4;
const int SIDES = 4;
const int MASK = (1 << N) - 1;
int possible[N * N], s[SIDES * N], e[SIDES * N], inc[SIDES * N];
int results[N][N];
int* my_clues;
vector<int> order;

int _clues[SIDES * N];
void print_binary(int x) {
    for (int i = N - 1; i >= 0; i--) printf("%d", (x & (1 << i)) ? 1 : 0);
}

void print_possible() {
    for (int i = 0; i < N * N; i++) {
        print_binary(possible[i]);
        printf(" ");
        if (i % N == N - 1) printf("\n");
    }
}

void set_value(int x, int v) {
    int m = MASK ^ (1 << v);
    int s_row = x - x % N;
    int s_col = x % N;
    for (int i = 0; i < N; i++) {
        possible[s_row + i] &= m;
        possible[s_col + i * N] &= m;
    }
    possible[x] = 1 << v;
}

int check_unique() {
    int n_decides = 0;
    for (int i = 0; i < SIDES / 2 * N; i++) {

        map<int, vector<int> > possible_indices;
        for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
            for (int l = 0; l < N; l++) 
                if ((1 << l) & possible[j]) {
                    possible_indices[l].push_back(j);
                }
        }

        for (auto const &iter : possible_indices) {
            int val = iter.first;
            if (iter.second.size() == 1) {
                int idx = iter.second[0];
                if (possible[idx] != (1 << val)) {
                    n_decides++;
                    set_value(idx, val);
                }
            }
        }
    }
    return n_decides;
}

int count_possible(int val) {
    int n = 0;
    while (val) {
        n += val & 1;
        val >>= 1;
    }
    return n;
}

bool valid() {
    for (int i = 0; i < SIDES * N; i++) {
        if (my_clues[i] == 0) continue;

        bool is_decided = true;
        for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
            if (count_possible(possible[j]) != 1) {
                is_decided = false;
                break;
            }
        }

        if (is_decided) {
            int largest = 0, n_clue = 0;
            for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
                if (largest < possible[j]) {
                    n_clue++;
                    largest = possible[j];
                }
            }
            if (n_clue != my_clues[i]) return false;
        }
    }

    return true;
}

void write_results() {
    for (int i = 0; i < N * N; i++) {
        int x = i / N, y = i % N;
        for (int j = 0; j < N; j++) {
            if ((1 << j) == possible[i]) {
                results[x][y] = j + 1;
                break;
            }
        }
    }
}

bool dfs(int idx) {
    // printf("%d %d\n", idx, order[idx]);
    if (idx >= order.size()) {
        if (valid()) {
            write_results();
            return true;
        }
        return false;
    }

    int i = order[idx];
    int possible_bak[N * N];
    memcpy(possible_bak, possible, sizeof(int) * N * N);

    for (int j = 0; j < N; j++) {
        int m = (1 << j) & possible[i];
        if (m == 0) continue;

        set_value(i, j);
        bool found = false;
        if (valid()) {
            found = dfs(idx + 1);
        }
        if (found) {
            return true;
        }
        memcpy(possible, possible_bak, sizeof(int) * N * N);
    }
    return false;
}

int** SolvePuzzle(int *clues) {
    my_clues = clues;
    for (int i = 0; i < N * N; i++) possible[i] = MASK;

    for (int i = 0; i < N; i++) {
        s[i] = i;
        e[i] = 3 * N + i;
        inc[i] = N;
    }

    for (int i = 0, j = N; i < N; i++, j++) {
        s[j] = i * N + N - 1;
        e[j] = i * N;
        inc[j] = -1;
    }

    for (int i = 0, j = 2 * N; i < N; i++, j++) {
        s[j] = 4 * N - 1 - i;
        e[j] = N - 1 - i;
        inc[j] = -N;
    }

    for (int i = 0, j = 3 * N; i < N; i++, j++) {
        s[j] = (N - i - 1) * N;
        e[j] = (N - i) * N - 1;
        inc[j] = 1;
    }

    for (int i = 0; i < SIDES * N; i++) {
        if (my_clues[i] == 0) continue;
        for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
            int m = MASK;
            for (int l = N + k - my_clues[i] + 1; l < N; l++) m ^= 1 << l;
            possible[j] &= m;
        }
    }

    while (check_unique() > 0);

    vector<pair<int, int>> idx_npos;
    for (int i = 0; i < N * N; i++) {
        int n_possible = count_possible(possible[i]);
        if (n_possible > 1) {
            idx_npos.push_back(make_pair(n_possible, i));
        }
    }

    sort(idx_npos.begin(), idx_npos.end());
    for (int i = 0; i < idx_npos.size(); i++) {
        order.push_back(idx_npos[i].second);
    }
    dfs(0);

    int** p = new int*[N];
    for (int i = 0; i < N; i++) p[i] = results[i];
    return p;
}

6 days agoRefactorDiscuss
2 kyu
6 By 6 Skyscrapers
C++:
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <map>
#include <vector>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6;
const int SIDES = 4;
const int MASK = (1 << N) - 1;
int possible[N * N], s[SIDES * N], e[SIDES * N], inc[SIDES * N];
int results[N][N];
vector<int> my_clues;
vector<int> order;

void print_binary(int x) {
    for (int i = N - 1; i >= 0; i--) printf("%d", (x & (1 << i)) ? 1 : 0);
}

void print_possible() {
    for (int i = 0; i < N * N; i++) {
        print_binary(possible[i]);
        printf(" ");
        if (i % N == N - 1) printf("\n");
    }
}

void set_value(int x, int v) {
    int m = MASK ^ (1 << v);
    int s_row = x - x % N;
    int s_col = x % N;
    for (int i = 0; i < N; i++) {
        possible[s_row + i] &= m;
        possible[s_col + i * N] &= m;
    }
    possible[x] = 1 << v;
}

int check_unique() {
    int n_decides = 0;
    for (int i = 0; i < SIDES / 2 * N; i++) {

        map<int, vector<int> > possible_indices;
        for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
            for (int l = 0; l < N; l++) 
                if ((1 << l) & possible[j]) {
                    possible_indices[l].push_back(j);
                }
        }

        for (auto const &iter : possible_indices) {
            int val = iter.first;
            if (iter.second.size() == 1) {
                int idx = iter.second[0];
                if (possible[idx] != (1 << val)) {
                    n_decides++;
                    set_value(idx, val);
                }
            }
        }
    }
    return n_decides;
}

int count_possible(int val) {
    int n = 0;
    while (val) {
        n += val & 1;
        val >>= 1;
    }
    return n;
}

bool valid() {
    for (int i = 0; i < SIDES * N; i++) {
        if (my_clues[i] == 0) continue;

        bool is_decided = true;
        for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
            if (count_possible(possible[j]) != 1) {
                is_decided = false;
                break;
            }
        }

        if (is_decided) {
            int largest = 0, n_clue = 0;
            for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
                if (largest < possible[j]) {
                    n_clue++;
                    largest = possible[j];
                }
            }
            if (n_clue != my_clues[i]) return false;
        }
    }

    return true;
}

void write_results() {
    for (int i = 0; i < N * N; i++) {
        int x = i / N, y = i % N;
        for (int j = 0; j < N; j++) {
            if ((1 << j) == possible[i]) {
                results[x][y] = j + 1;
                break;
            }
        }
    }
}

bool dfs(int idx) {
    // printf("%d %d\n", idx, order[idx]);
    if (idx >= order.size()) {
        if (valid()) {
            write_results();
            return true;
        }
        return false;
    }

    int i = order[idx];
    int possible_bak[N * N];
    memcpy(possible_bak, possible, sizeof(int) * N * N);

    for (int j = 0; j < N; j++) {
        int m = (1 << j) & possible[i];
        if (m == 0) continue;

        set_value(i, j);
        bool found = false;
        if (valid()) {
            found = dfs(idx + 1);
        }
        if (found) {
            return true;
        }
        memcpy(possible, possible_bak, sizeof(int) * N * N);
    }
    return false;
}

vector<vector<int>> SolvePuzzle(const vector<int> &clues) {
    my_clues = clues;
    for (int i = 0; i < N * N; i++) possible[i] = MASK;

    for (int i = 0; i < N; i++) {
        s[i] = i;
        e[i] = (N - 1) * N + i;
        inc[i] = N;
    }

    for (int i = 0, j = N; i < N; i++, j++) {
        s[j] = i * N + N - 1;
        e[j] = i * N;
        inc[j] = -1;
    }

    for (int i = 0, j = 2 * N; i < N; i++, j++) {
        s[j] = N * N - 1 - i;
        e[j] = N - 1 - i;
        inc[j] = -N;
    }

    for (int i = 0, j = 3 * N; i < N; i++, j++) {
        s[j] = (N - i - 1) * N;
        e[j] = (N - i) * N - 1;
        inc[j] = 1;
    }

    for (int i = 0; i < SIDES * N; i++) 
    {
        // int i = 12;
        if (my_clues[i] == 0) continue;
        for (int j = s[i], k = 0; k < N; j += inc[i], k++) {
            int m = MASK;
            for (int l = N + k - my_clues[i] + 1; l < N; l++) m ^= 1 << l;
            possible[j] &= m;
        }
        // printf("%d %d\n", i, my_clues[i]);
        // print_possible();
    }

    while (check_unique() > 0);

    vector<pair<int, int>> idx_npos;
    for (int i = 0; i < N * N; i++) {
        int n_possible = count_possible(possible[i]);
        if (n_possible > 1) {
            idx_npos.push_back(make_pair(n_possible, i));
        }
    }

    sort(idx_npos.begin(), idx_npos.end());
    order.clear();
    for (int i = 0; i < idx_npos.size(); i++) {
        order.push_back(idx_npos[i].second);
    }
    dfs(0);

    vector<vector<int>> r;
    for (int i = 0; i < N; i++) {
        vector<int> vec;
        for (int j = 0; j < N; j++) vec.push_back(results[i][j]);
        r.push_back(vec);
    }
    return r;
}
6 days agoRefactorDiscuss
1 kyu
Tiny Three-Pass Compiler
OCaml:
let tokenize code =
  let rec explode string =
    if String.length string = 0 then []
    else [String.sub string 0 1] @
         explode (String.sub string 1 ((String.length string) - 1))
  in
  let specialChars =
    [
      "["; "]"; "-"; "+"; "*"; "/"; "("; ")"
    ]
  in
  let nonSpecialHelper = function
    | "" -> []
    | str -> [str]
  in
  let rec tokenizeHelper = function
    | [],currentItem, tokens ->
      tokens @ (nonSpecialHelper currentItem)
    | " "::lst, currentItem, tokens ->
      tokenizeHelper(
        lst,"",
        tokens @ nonSpecialHelper currentItem)
    | item::lst, currentItem, tokens ->
      if List.mem item specialChars then
        tokenizeHelper(
          lst, "",
          tokens @ nonSpecialHelper currentItem @ [item])
      else
        tokenizeHelper(lst, currentItem ^ item,tokens)
  in
  tokenizeHelper(explode code, "", [])

type ast =
  | Imm of int  (* immediate value *)
  | Arg of int  (* reference to n-th argument *)
  | Add of (ast * ast) (* add first to second *)
  | Sub of (ast * ast) (* subtract second from first *)
  | Mul of (ast * ast) (* multiply first by second *)
  | Div of (ast * ast) (* divide first by second *)

exception CompilerError of string

module type COMPILER =
sig
  val pass1: string -> ast
  val pass2: ast -> ast
  val codeGen: ast -> string list
  val compile: string -> string list
end

module Compiler : COMPILER =
struct
  let pass1 code =
    let is_number s = s.[0] >= '0' && s.[0] <= '9' in
    let rec arg_list code n = match code with
        "]" :: code -> (code, [])
      | var :: code ->
        let (code, args) = arg_list code (n + 1) in
        (code, (var, n) :: args)
      | _ -> raise (CompilerError "arg list expected") in
    let (code, symbols) = arg_list (List.tl (tokenize code)) 0 in
    let rec expression code =
      let (code, e1) = term code in expression_rest code e1
    and expression_rest code e1 = match code with
      | "+" :: code ->
        let (code, e2) = term code in expression_rest code (Add(e1, e2))
      | "-" :: code ->
        let (code, e2) = term code in expression_rest code (Sub(e1, e2))
      | _ -> (code, e1)
    and term code = let (code, e1) = factor code in term_rest code e1
    and term_rest code e1 = match code with
      | "*" :: code ->
        let (code, e2) = factor code in term_rest code (Mul(e1, e2))
      | "/" :: code ->
        let (code, e2) = factor code in term_rest code (Div(e1, e2))
      | _ -> (code, e1)
    and factor code = match code with
      | "(" :: code -> let (code, e) = expression code in (List.tl code, e)
      | x :: code ->
        if is_number x then (code, Imm(int_of_string x))
        else (code, Arg(List.assoc x symbols))
      | _ -> raise (CompilerError "syntax error") in
    expression code |> snd

  let rec pass2 = function
      Imm(_) | Arg(_) as x -> x
    | Add(x, y) -> let a = pass2 x and b = pass2 y in
      begin match (a, b) with
          (Imm(x), Imm(y)) -> Imm(x + y)
        | _ -> Add(a, b)
      end
    | Sub(x, y) -> let a = pass2 x and b = pass2 y in
      begin match (a, b) with
          (Imm(x), Imm(y)) -> Imm(x - y)
        | _ -> Sub(a, b)
      end
    | Mul(x, y) -> let a = pass2 x and b = pass2 y in
      begin match (a, b) with
          (Imm(x), Imm(y)) -> Imm(x * y)
        | _ -> Mul(a, b)
      end
    | Div(x, y) -> let a = pass2 x and b = pass2 y in
      begin match (a, b) with
          (Imm(x), Imm(y)) -> Imm(x / y)
        | _ -> Div(a, b)
      end

  let rec codeGen = function
      Imm(x) -> [Printf.sprintf "IM %d" x]
    | Arg(x) -> [Printf.sprintf "AR %d" x]
    | Add(x, y) -> (codeGen x) @ ["PU"] @ (codeGen y) @ ["SW"; "PO"; "AD"]
    | Sub(x, y) -> (codeGen x) @ ["PU"] @ (codeGen y) @ ["SW"; "PO"; "SU"]
    | Mul(x, y) -> (codeGen x) @ ["PU"] @ (codeGen y) @ ["SW"; "PO"; "MU"]
    | Div(x, y) -> (codeGen x) @ ["PU"] @ (codeGen y) @ ["SW"; "PO"; "DI"]

  let compile code =
    codeGen(pass2(pass1 code))
end

let rec simualte : string list * int list -> int =
  let stack = Stack.create () in
  let r0 = ref 0 in
  let r1 = ref 0 in
  function
  | ([],argumets) -> !r0
  | ("SU"::lst,argumets) ->
    r0 := !r0 - !r1;
    simualte(lst,argumets)
  | ("DI"::lst,argumets) ->
    r0 := !r0 / !r1;
    simualte(lst,argumets)
  | ("MU"::lst,argumets) ->
    r0 := !r0 * !r1;
    simualte(lst,argumets)
  | ("AD"::lst,argumets) ->
    r0 := !r0 + !r1;
    simualte(lst,argumets)
  | ("PU"::lst,argumets) ->
    Stack.push !r0 stack;
    simualte(lst,argumets)
  | ("PO"::lst,argumets) ->
    r0 := (Stack.pop stack);
    simualte(lst,argumets)
  | ("SW"::lst,argumets) ->
    let tmp = !r0 in
    r0 := !r1;
    r1 := tmp;
    simualte(lst,argumets)
  | (op::lst,argumets) ->
    let op_code = String.sub op 0 2 in
    let value =
      int_of_string
        (String.sub op 3 ((String.length op) - 3))
    in
    match op_code with
    | "IM" ->
      r0 := value;
      simualte(lst,argumets)
    | "AR" ->
      r0 := List.nth argumets value;
      simualte(lst,argumets)
    | _ -> raise (CompilerError "bad assembly")
6 days agoRefactorDiscuss
1 kyu
Simple Interactive Interpreter
JavaScript:
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function Interpreter()
{
    this.vars = {};
    this.functions = {};
}

Interpreter.prototype.tokenize = function (program)
{
    if (program === "")
        return [];

    var regex = /\s*(=>|[-+*\/\%=\(\)]|[A-Za-z_][A-Za-z0-9_]*|[0-9]*\.?[0-9]+)\s*/g;
    return program.split(regex).filter(function (s) { return !s.match(/^\s*$/); });
};

Interpreter.prototype.input = function(expr)
{
    var tokens = this.tokenize(expr);
    if (tokens.length == 0)
      return '';
    let op = '+', preops = []; // preops is for parentheses
    let unassigned_vars = [], nest_vars = null, is_nest = false; // nest vars should be assigned first.
    let stack = [];
    let digit = 0;
    /////////////////////////// Check if the input is vaild /////////////////////////////
    if (tokens.length > 1)
    {
      for (let i = 0; i < tokens.length; i++)
      {
        if (isNumeric(tokens[i]))
          digit += 1;
      }
      if (digit == tokens.length)
        throw "Error";
    }
    //////////////////////////////////////////////////////////////////////////////////////
    ////////////////////////////////User Defined Functions////////////////////////////////
    if (tokens[0] == 'fn')
    {
      let seperator = tokens.indexOf('=>');
      if (seperator == -1 || tokens[1] in this.vars) //no arrow or has duplicate name with a variable
        throw "Error";
      let args = tokens.slice(2, seperator);
      let body = tokens.slice(seperator+1).join(' ');
      let duplicate = {}; // Check if there is no duplicate arguments of the function
      for (let i = 0; i < args.length; i++)
      {
        if (args[i] in duplicate)
          throw "Error";
        duplicate[args[i]] = 1;
      }
      for (let i = 0; i < body.length; i++) // Check if there is any undefined variable in the function
      {
        if (/^[a-zA-Z]+$/.test(body[i]) && !(body[i] in duplicate))
          throw "Error";
      }
      this.functions[tokens[1]] = {args: args, body: body}; // If vaild, save it to this.functions object
      return '';
    }
    ///////////////////////////////////////////////////////////////////////////////////////
    //////////////////////////// Call User Defined Functions //////////////////////////////
    if (tokens[0] in this.functions)
    {
      while (tokens.length >= 1) //Impelement Chained Functions
      {
        let function_name_index = 0, current_function = [];
        for (let i = 0; i < tokens.length; i++)
        {
          if (tokens[i] in this.functions)
            function_name_index = i;
        }
        for (let i = 0; i < this.functions[tokens[function_name_index]].args.length+1; i++)
          current_function.push(tokens[function_name_index + i]);
        let tail = tokens.slice(function_name_index + this.functions[tokens[function_name_index]].args.length+1);
        tokens = tokens.slice(0, function_name_index);
        let interpreter = new Interpreter();
        let args = this.functions[current_function[0]].args;
        if (args.length != current_function.length - 1)
          throw "Error";
        for (let i = 0; i < args.length; i++)
          interpreter.input(args[i] + ' = ' + current_function[i+1]);
        let function_value = interpreter.input(this.functions[current_function[0]].body);
        tokens.push(function_value);
        tokens = tokens.concat(tail);
        if (tokens.length == 1)
          return tokens[0];
      }
    }
    /////////////////////// Mathmatical Expression Calaulation ///////////////////////////////
    for (let i = 0; i < tokens.length; i++)
    {
      if (isNumeric(tokens[i]))
      {
        let temp = parseInt(tokens[i]);
        if (op == '+')
          stack.push(temp);
        else if (op == '-')
          stack.push(-temp);
        else if (op == '*')
        {
          let temp1 = stack.pop();
          stack.push(temp1 * temp);
        }
        else if (op == '/')
        {
          let temp1 = stack.pop();
          stack.push(temp1 / temp);
        }
        else if (op == '%')
        {
          let temp1 = stack.pop();
          stack.push(temp1 % temp);
        }
      }
      else if (/^[a-zA-Z]+$/.test(tokens[i]))
      {
        if (!(tokens[i] in this.vars))
        {
          if (tokens[i+1] != '=')
            throw "Error";
          this.vars[tokens[i]] = 0;
          if (is_nest)
            nest_vars = tokens[i];
          else
            unassigned_vars.push(tokens[i]);
        }
        else
        {
          if (tokens[i+1] != '=')
            stack.push(this.vars[tokens[i]]);
          else
            if (is_nest) // For nest assignment
              nest_vars = tokens[i]; // For basic and chain assignment
            else
              unassigned_vars.push(tokens[i]);
        }
      }
      else if (tokens[i] == '=')
      {
        if (i == tokens.length || tokens[i+1] == '=')
          throw "Error";
        continue;
      }
      else if (tokens[i] == '(')
      {
        is_nest = true;
        preops.push(op);
        op = '+';
        stack.push(tokens[i]);
      }
      ////////////////////////// Deal With the Parenthesis ///////////////////////////
      else if (tokens[i] == ')')
      {
        let temp = [];
        while (true)
        {
          let t = stack.pop();
          if (t == '(')
            break;
          temp.push(t);
        }
        let tempsum = temp.reduce(function(a, b) {
          return a + b;
        }, 0);
        ////////////////////////////// Nest Assignment ///////////////////////////////
        if (nest_vars)
        {
          this.vars[nest_vars] = tempsum;
          nest_vars = null;
        }
        //////////////////////////////////////////////////////////////////////////////
        isnest = false;
        let preop = '+';
        if (preops.length > 0)
          preop = preops.pop();
        if (preop == '+')
          stack.push(tempsum);
        else if (preop == '-')
          stack.push(-tempsum);
        else if (preop == '*')
        {
          let t1 = stack.pop();
          stack.push(t1 * tempsum);
        }
        else if (preop == '/')
        {
          let t1 = stack.pop();
          stack.push(t1 / tempsum);
        }
        else if (preop == '%')
        {
          let t1 = stack.pop();
          stack.push(t1 % tempsum);
        }
      }
      ////////////////////////////////////////////////////////////////////////////////
      else
        op = tokens[i];
    }
    let res = stack.reduce(function(a, b) {
      return a + b;
    }, 0);
    //////////////////////////////////////////////////////////////////////////////////
    ////////////////////// Assign Value to Unsigned Variables ////////////////////////
    for (let i = 0; i < unassigned_vars.length; i++) // Chain Assignment
      this.vars[unassigned_vars[i]] = res;
    //////////////////////////////////////////////////////////////////////////////////
    return res;
};
6 days agoRefactorDiscuss
8 kyu
I love you, a little , a lot, passionately ... not at all
Java:
public class Sid {
    public static String howMuchILoveYou(int nb_petals) {
    
      String risp[] ={"not at all", "I love you",  "a little", "a lot", "passionately", "madly"};
      
      return risp[nb_petals%6];
      
    }
}
3 weeks agoRefactor
8 kyu
Multiply
Java:
public class Multiply {
    public static Double multiply(Double a, Double b) {
        return a * b;
    }
}